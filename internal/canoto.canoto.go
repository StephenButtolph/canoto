// Code generated by canoto. DO NOT EDIT.
// versions:
// 	canoto v0.11.1
// source: canoto.go

package examples

import (
	"io"
	"sync/atomic"
	"unicode/utf8"

	"github.com/StephenButtolph/canoto"
)

// Ensure that unused imports do not error
var (
	_ atomic.Int64

	_ = io.ErrUnexpectedEOF
	_ = utf8.ValidString
)

const (
	canoto__LargestFieldNumber__Int32__tag = "\xf8\xff\xff\xff\x0f" // canoto.Tag(536870911, canoto.Varint)
)

type canotoData_LargestFieldNumber struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*LargestFieldNumber[T1]) MakeCanoto() *LargestFieldNumber[T1] {
	return new(LargestFieldNumber[T1])
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *LargestFieldNumber[T1]) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *LargestFieldNumber[T1]) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = LargestFieldNumber[T1]{}
	c.canotoData.size = len(r.B)

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 536870911:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int32); err != nil {
				return err
			}
			if canoto.IsZero(c.Int32) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *LargestFieldNumber[T1]) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *LargestFieldNumber[T1]) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	if !canoto.IsZero(c.Int32) {
		c.canotoData.size += len(canoto__LargestFieldNumber__Int32__tag) + canoto.SizeInt(c.Int32)
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *LargestFieldNumber[T1]) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *LargestFieldNumber[T1]) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *LargestFieldNumber[T1]) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Int32) {
		canoto.Append(&w, canoto__LargestFieldNumber__Int32__tag)
		canoto.AppendInt(&w, c.Int32)
	}
	return w
}

const (
	canoto__OneOf__A1__tag = "\x08" // canoto.Tag(1, canoto.Varint)
	canoto__OneOf__B1__tag = "\x18" // canoto.Tag(3, canoto.Varint)
	canoto__OneOf__B2__tag = "\x20" // canoto.Tag(4, canoto.Varint)
	canoto__OneOf__C__tag  = "\x28" // canoto.Tag(5, canoto.Varint)
	canoto__OneOf__D__tag  = "\x30" // canoto.Tag(6, canoto.Varint)
	canoto__OneOf__A2__tag = "\x38" // canoto.Tag(7, canoto.Varint)
)

type canotoData_OneOf struct {
	size int

	AOneOf uint32
	BOneOf uint32
}

// MakeCanoto creates a new empty value.
func (*OneOf) MakeCanoto() *OneOf {
	return new(OneOf)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *OneOf) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *OneOf) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = OneOf{}
	c.canotoData.size = len(r.B)

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.AOneOf != 0 {
				return canoto.ErrDuplicateOneOf
			}
			c.canotoData.AOneOf = 1

			if err := canoto.ReadInt(&r, &c.A1); err != nil {
				return err
			}
			if canoto.IsZero(c.A1) {
				return canoto.ErrZeroValue
			}
		case 3:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.BOneOf != 0 {
				return canoto.ErrDuplicateOneOf
			}
			c.canotoData.BOneOf = 3

			if err := canoto.ReadInt(&r, &c.B1); err != nil {
				return err
			}
			if canoto.IsZero(c.B1) {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.BOneOf != 0 {
				return canoto.ErrDuplicateOneOf
			}
			c.canotoData.BOneOf = 4

			if err := canoto.ReadInt(&r, &c.B2); err != nil {
				return err
			}
			if canoto.IsZero(c.B2) {
				return canoto.ErrZeroValue
			}
		case 5:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.C); err != nil {
				return err
			}
			if canoto.IsZero(c.C) {
				return canoto.ErrZeroValue
			}
		case 6:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.D); err != nil {
				return err
			}
			if canoto.IsZero(c.D) {
				return canoto.ErrZeroValue
			}
		case 7:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.AOneOf != 0 {
				return canoto.ErrDuplicateOneOf
			}
			c.canotoData.AOneOf = 7

			if err := canoto.ReadInt(&r, &c.A2); err != nil {
				return err
			}
			if canoto.IsZero(c.A2) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *OneOf) ValidCanoto() bool {
	if c == nil {
		return true
	}
	var (
		AOneOf uint32
		BOneOf uint32
	)
	if !canoto.IsZero(c.A1) {
		if AOneOf != 0 {
			return false
		}
		AOneOf = 1
	}
	if !canoto.IsZero(c.B1) {
		if BOneOf != 0 {
			return false
		}
		BOneOf = 3
	}
	if !canoto.IsZero(c.B2) {
		if BOneOf != 0 {
			return false
		}
		BOneOf = 4
	}
	if !canoto.IsZero(c.A2) {
		if AOneOf != 0 {
			return false
		}
		AOneOf = 7
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *OneOf) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.AOneOf = 0
	c.canotoData.BOneOf = 0
	c.canotoData.size = 0
	if !canoto.IsZero(c.A1) {
		c.canotoData.size += len(canoto__OneOf__A1__tag) + canoto.SizeInt(c.A1)
		c.canotoData.AOneOf = 1
	}
	if !canoto.IsZero(c.B1) {
		c.canotoData.size += len(canoto__OneOf__B1__tag) + canoto.SizeInt(c.B1)
		c.canotoData.BOneOf = 3
	}
	if !canoto.IsZero(c.B2) {
		c.canotoData.size += len(canoto__OneOf__B2__tag) + canoto.SizeInt(c.B2)
		c.canotoData.BOneOf = 4
	}
	if !canoto.IsZero(c.C) {
		c.canotoData.size += len(canoto__OneOf__C__tag) + canoto.SizeInt(c.C)
	}
	if !canoto.IsZero(c.D) {
		c.canotoData.size += len(canoto__OneOf__D__tag) + canoto.SizeInt(c.D)
	}
	if !canoto.IsZero(c.A2) {
		c.canotoData.size += len(canoto__OneOf__A2__tag) + canoto.SizeInt(c.A2)
		c.canotoData.AOneOf = 7
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *OneOf) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// CachedWhichOneOfA returns the previously calculated field number used
// to represent A.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *OneOf) CachedWhichOneOfA() uint32 {
	return c.canotoData.AOneOf
}

// CachedWhichOneOfB returns the previously calculated field number used
// to represent B.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *OneOf) CachedWhichOneOfB() uint32 {
	return c.canotoData.BOneOf
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *OneOf) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *OneOf) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.A1) {
		canoto.Append(&w, canoto__OneOf__A1__tag)
		canoto.AppendInt(&w, c.A1)
	}
	if !canoto.IsZero(c.B1) {
		canoto.Append(&w, canoto__OneOf__B1__tag)
		canoto.AppendInt(&w, c.B1)
	}
	if !canoto.IsZero(c.B2) {
		canoto.Append(&w, canoto__OneOf__B2__tag)
		canoto.AppendInt(&w, c.B2)
	}
	if !canoto.IsZero(c.C) {
		canoto.Append(&w, canoto__OneOf__C__tag)
		canoto.AppendInt(&w, c.C)
	}
	if !canoto.IsZero(c.D) {
		canoto.Append(&w, canoto__OneOf__D__tag)
		canoto.AppendInt(&w, c.D)
	}
	if !canoto.IsZero(c.A2) {
		canoto.Append(&w, canoto__OneOf__A2__tag)
		canoto.AppendInt(&w, c.A2)
	}
	return w
}

const (
	canoto__GenericField__Value__tag                = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__GenericField__RepeatedValue__tag        = "\x12" // canoto.Tag(2, canoto.Len)
	canoto__GenericField__FixedRepeatedValue__tag   = "\x1a" // canoto.Tag(3, canoto.Len)
	canoto__GenericField__Pointer__tag              = "\x22" // canoto.Tag(4, canoto.Len)
	canoto__GenericField__RepeatedPointer__tag      = "\x2a" // canoto.Tag(5, canoto.Len)
	canoto__GenericField__FixedRepeatedPointer__tag = "\x32" // canoto.Tag(6, canoto.Len)
	canoto__GenericField__Field__tag                = "\x3a" // canoto.Tag(7, canoto.Len)
	canoto__GenericField__RepeatedField__tag        = "\x42" // canoto.Tag(8, canoto.Len)
	canoto__GenericField__FixedRepeatedField__tag   = "\x4a" // canoto.Tag(9, canoto.Len)
)

type canotoData_GenericField struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*GenericField[T1, T2, T3]) MakeCanoto() *GenericField[T1, T2, T3] {
	return new(GenericField[T1, T2, T3])
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *GenericField[T1, T2, T3]) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *GenericField[T1, T2, T3]) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = GenericField[T1, T2, T3]{}
	c.canotoData.size = len(r.B)

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := T2(&c.Value).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__GenericField__RepeatedValue__tag)
			if err != nil {
				return err
			}

			c.RepeatedValue = canoto.MakeSlice(c.RepeatedValue, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&c.RepeatedValue[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__GenericField__RepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&c.RepeatedValue[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 3:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&c.FixedRepeatedValue[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedValue) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__GenericField__FixedRepeatedValue__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__GenericField__FixedRepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&c.FixedRepeatedValue[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Pointer = canoto.MakePointer(c.Pointer)
			if err := T2(c.Pointer).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 5:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__GenericField__RepeatedPointer__tag)
			if err != nil {
				return err
			}

			c.RepeatedPointer = canoto.MakeSlice(c.RepeatedPointer, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedPointer[0] = canoto.MakePointer(c.RepeatedPointer[0])
				if err := T2(c.RepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__GenericField__RepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedPointer[1+i] = canoto.MakePointer(c.RepeatedPointer[1+i])
				if err := T2(c.RepeatedPointer[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 6:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			c.FixedRepeatedPointer[0] = nil
			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[0] = canoto.MakePointer(c.FixedRepeatedPointer[0])
				if err := T2(c.FixedRepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedPointer) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__GenericField__FixedRepeatedPointer__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__GenericField__FixedRepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					c.FixedRepeatedPointer[1+i] = nil
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[1+i] = canoto.MakePointer(c.FixedRepeatedPointer[1+i])
				if err := T2(c.FixedRepeatedPointer[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 7:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Field = c.Field.MakeCanoto()
			if err := c.Field.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 8:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__GenericField__RepeatedField__tag)
			if err != nil {
				return err
			}

			c.RepeatedField = canoto.MakeSlice(c.RepeatedField, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedField[0] = c.RepeatedField[0].MakeCanoto()
				if err := c.RepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__GenericField__RepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedField[1+i] = c.RepeatedField[1+i].MakeCanoto()
				if err := c.RepeatedField[1+i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 9:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			c.FixedRepeatedField[0] = canoto.Zero(c.FixedRepeatedField[0])
			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[0] = c.FixedRepeatedField[0].MakeCanoto()
				if err := c.FixedRepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedField) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__GenericField__FixedRepeatedField__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__GenericField__FixedRepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					c.FixedRepeatedField[1+i] = canoto.Zero(c.FixedRepeatedField[1+i])
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[1+i] = c.FixedRepeatedField[1+i].MakeCanoto()
				if err := c.FixedRepeatedField[1+i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *GenericField[T1, T2, T3]) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !T2(&c.Value).ValidCanoto() {
		return false
	}
	for i := range c.RepeatedValue {
		if !T2(&c.RepeatedValue[i]).ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedValue {
		if !T2(&(&c.FixedRepeatedValue)[i]).ValidCanoto() {
			return false
		}
	}
	if c.Pointer != nil && !T2(c.Pointer).ValidCanoto() {
		return false
	}
	for i := range c.RepeatedPointer {
		if c.RepeatedPointer[i] != nil && !T2(c.RepeatedPointer[i]).ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedPointer {
		if (&c.FixedRepeatedPointer)[i] != nil && !T2((&c.FixedRepeatedPointer)[i]).ValidCanoto() {
			return false
		}
	}
	if !c.Field.ValidCanoto() {
		return false
	}
	for i := range c.RepeatedField {
		if !c.RepeatedField[i].ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedField {
		if !(&c.FixedRepeatedField)[i].ValidCanoto() {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *GenericField[T1, T2, T3]) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	T2(&c.Value).CalculateCanotoCache()
	if fieldSize := T2(&c.Value).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__GenericField__Value__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	for i := range c.RepeatedValue {
		T2(&c.RepeatedValue[i]).CalculateCanotoCache()
		fieldSize := T2(&c.RepeatedValue[i]).CachedCanotoSize()
		c.canotoData.size += len(canoto__GenericField__RepeatedValue__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedValue {
			T2(&c.FixedRepeatedValue[i]).CalculateCanotoCache()
			fieldSize := T2(&c.FixedRepeatedValue[i]).CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += len(canoto__GenericField__FixedRepeatedValue__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			c.canotoData.size += totalSize
		}
	}
	if c.Pointer != nil {
		T2(c.Pointer).CalculateCanotoCache()
		if fieldSize := T2(c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			c.canotoData.size += len(canoto__GenericField__Pointer__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		}
	}
	for i := range c.RepeatedPointer {
		var fieldSize int
		if c.RepeatedPointer[i] != nil {
			T2(c.RepeatedPointer[i]).CalculateCanotoCache()
			fieldSize = T2(c.RepeatedPointer[i]).CachedCanotoSize()
		}
		c.canotoData.size += len(canoto__GenericField__RepeatedPointer__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedPointer {
			var fieldSize int
			if c.FixedRepeatedPointer[i] != nil {
				T2(c.FixedRepeatedPointer[i]).CalculateCanotoCache()
				fieldSize = T2(c.FixedRepeatedPointer[i]).CachedCanotoSize()
				fieldSizeSum += fieldSize
			}
			totalSize += len(canoto__GenericField__FixedRepeatedPointer__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			c.canotoData.size += totalSize
		}
	}
	c.Field.CalculateCanotoCache()
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__GenericField__Field__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	for i := range c.RepeatedField {
		c.RepeatedField[i].CalculateCanotoCache()
		fieldSize := c.RepeatedField[i].CachedCanotoSize()
		c.canotoData.size += len(canoto__GenericField__RepeatedField__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedField {
			c.FixedRepeatedField[i].CalculateCanotoCache()
			fieldSize := c.FixedRepeatedField[i].CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += len(canoto__GenericField__FixedRepeatedField__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			c.canotoData.size += totalSize
		}
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *GenericField[T1, T2, T3]) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *GenericField[T1, T2, T3]) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *GenericField[T1, T2, T3]) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := T2(&c.Value).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__GenericField__Value__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = T2(&c.Value).MarshalCanotoInto(w)
	}
	for i := range c.RepeatedValue {
		canoto.Append(&w, canoto__GenericField__RepeatedValue__tag)
		canoto.AppendInt(&w, int64(T2(&c.RepeatedValue[i]).CachedCanotoSize()))
		w = T2(&c.RepeatedValue[i]).MarshalCanotoInto(w)
	}
	{
		isZero := true
		for i := range c.FixedRepeatedValue {
			if T2(&c.FixedRepeatedValue[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedValue {
				canoto.Append(&w, canoto__GenericField__FixedRepeatedValue__tag)
				canoto.AppendInt(&w, int64(T2(&c.FixedRepeatedValue[i]).CachedCanotoSize()))
				w = T2(&c.FixedRepeatedValue[i]).MarshalCanotoInto(w)
			}
		}
	}
	if c.Pointer != nil {
		if fieldSize := T2(c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__GenericField__Pointer__tag)
			canoto.AppendInt(&w, int64(fieldSize))
			w = T2(c.Pointer).MarshalCanotoInto(w)
		}
	}
	for i := range c.RepeatedPointer {
		canoto.Append(&w, canoto__GenericField__RepeatedPointer__tag)
		var fieldSize int
		if c.RepeatedPointer[i] != nil {
			fieldSize = T2(c.RepeatedPointer[i]).CachedCanotoSize()
		}
		canoto.AppendInt(&w, int64(fieldSize))
		if fieldSize != 0 {
			w = T2(c.RepeatedPointer[i]).MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedPointer {
			if c.FixedRepeatedPointer[i] != nil && T2(c.FixedRepeatedPointer[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedPointer {
				canoto.Append(&w, canoto__GenericField__FixedRepeatedPointer__tag)
				var fieldSize int
				if c.FixedRepeatedPointer[i] != nil {
					fieldSize = T2(c.FixedRepeatedPointer[i]).CachedCanotoSize()
				}
				canoto.AppendInt(&w, int64(fieldSize))
				if fieldSize != 0 {
					w = T2(c.FixedRepeatedPointer[i]).MarshalCanotoInto(w)
				}
			}
		}
	}
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__GenericField__Field__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = c.Field.MarshalCanotoInto(w)
	}
	for i := range c.RepeatedField {
		canoto.Append(&w, canoto__GenericField__RepeatedField__tag)
		fieldSize := c.RepeatedField[i].CachedCanotoSize()
		canoto.AppendInt(&w, int64(fieldSize))
		if fieldSize != 0 {
			w = c.RepeatedField[i].MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedField {
			if c.FixedRepeatedField[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedField {
				canoto.Append(&w, canoto__GenericField__FixedRepeatedField__tag)
				fieldSize := c.FixedRepeatedField[i].CachedCanotoSize()
				canoto.AppendInt(&w, int64(fieldSize))
				if fieldSize != 0 {
					w = c.FixedRepeatedField[i].MarshalCanotoInto(w)
				}
			}
		}
	}
	return w
}

const (
	canoto__NestedGenericField__Value__tag                = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__NestedGenericField__RepeatedValue__tag        = "\x12" // canoto.Tag(2, canoto.Len)
	canoto__NestedGenericField__FixedRepeatedValue__tag   = "\x1a" // canoto.Tag(3, canoto.Len)
	canoto__NestedGenericField__Pointer__tag              = "\x22" // canoto.Tag(4, canoto.Len)
	canoto__NestedGenericField__RepeatedPointer__tag      = "\x2a" // canoto.Tag(5, canoto.Len)
	canoto__NestedGenericField__FixedRepeatedPointer__tag = "\x32" // canoto.Tag(6, canoto.Len)
	canoto__NestedGenericField__Field__tag                = "\x3a" // canoto.Tag(7, canoto.Len)
	canoto__NestedGenericField__RepeatedField__tag        = "\x42" // canoto.Tag(8, canoto.Len)
	canoto__NestedGenericField__FixedRepeatedField__tag   = "\x4a" // canoto.Tag(9, canoto.Len)
)

type canotoData_NestedGenericField struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*NestedGenericField[T1, T2, T3]) MakeCanoto() *NestedGenericField[T1, T2, T3] {
	return new(NestedGenericField[T1, T2, T3])
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *NestedGenericField[T1, T2, T3]) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *NestedGenericField[T1, T2, T3]) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = NestedGenericField[T1, T2, T3]{}
	c.canotoData.size = len(r.B)

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.Value).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__NestedGenericField__RepeatedValue__tag)
			if err != nil {
				return err
			}

			c.RepeatedValue = canoto.MakeSlice(c.RepeatedValue, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.RepeatedValue[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__NestedGenericField__RepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.RepeatedValue[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 3:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.FixedRepeatedValue[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedValue) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__NestedGenericField__FixedRepeatedValue__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__NestedGenericField__FixedRepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.FixedRepeatedValue[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Pointer = canoto.MakePointer(c.Pointer)
			if err := (c.Pointer).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 5:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__NestedGenericField__RepeatedPointer__tag)
			if err != nil {
				return err
			}

			c.RepeatedPointer = canoto.MakeSlice(c.RepeatedPointer, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedPointer[0] = canoto.MakePointer(c.RepeatedPointer[0])
				if err := (c.RepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__NestedGenericField__RepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedPointer[1+i] = canoto.MakePointer(c.RepeatedPointer[1+i])
				if err := (c.RepeatedPointer[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 6:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			c.FixedRepeatedPointer[0] = nil
			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[0] = canoto.MakePointer(c.FixedRepeatedPointer[0])
				if err := (c.FixedRepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedPointer) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__NestedGenericField__FixedRepeatedPointer__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__NestedGenericField__FixedRepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					c.FixedRepeatedPointer[1+i] = nil
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[1+i] = canoto.MakePointer(c.FixedRepeatedPointer[1+i])
				if err := (c.FixedRepeatedPointer[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 7:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Field = c.Field.MakeCanoto()
			if err := c.Field.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 8:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__NestedGenericField__RepeatedField__tag)
			if err != nil {
				return err
			}

			c.RepeatedField = canoto.MakeSlice(c.RepeatedField, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedField[0] = c.RepeatedField[0].MakeCanoto()
				if err := c.RepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__NestedGenericField__RepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedField[1+i] = c.RepeatedField[1+i].MakeCanoto()
				if err := c.RepeatedField[1+i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 9:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			c.FixedRepeatedField[0] = canoto.Zero(c.FixedRepeatedField[0])
			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[0] = c.FixedRepeatedField[0].MakeCanoto()
				if err := c.FixedRepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedField) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__NestedGenericField__FixedRepeatedField__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__NestedGenericField__FixedRepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					c.FixedRepeatedField[1+i] = canoto.Zero(c.FixedRepeatedField[1+i])
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[1+i] = c.FixedRepeatedField[1+i].MakeCanoto()
				if err := c.FixedRepeatedField[1+i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *NestedGenericField[T1, T2, T3]) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.Value).ValidCanoto() {
		return false
	}
	for i := range c.RepeatedValue {
		if !(&c.RepeatedValue[i]).ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedValue {
		if !(&(&c.FixedRepeatedValue)[i]).ValidCanoto() {
			return false
		}
	}
	if c.Pointer != nil && !(c.Pointer).ValidCanoto() {
		return false
	}
	for i := range c.RepeatedPointer {
		if c.RepeatedPointer[i] != nil && !(c.RepeatedPointer[i]).ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedPointer {
		if (&c.FixedRepeatedPointer)[i] != nil && !((&c.FixedRepeatedPointer)[i]).ValidCanoto() {
			return false
		}
	}
	if !c.Field.ValidCanoto() {
		return false
	}
	for i := range c.RepeatedField {
		if !c.RepeatedField[i].ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedField {
		if !(&c.FixedRepeatedField)[i].ValidCanoto() {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *NestedGenericField[T1, T2, T3]) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	(&c.Value).CalculateCanotoCache()
	if fieldSize := (&c.Value).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__NestedGenericField__Value__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	for i := range c.RepeatedValue {
		(&c.RepeatedValue[i]).CalculateCanotoCache()
		fieldSize := (&c.RepeatedValue[i]).CachedCanotoSize()
		c.canotoData.size += len(canoto__NestedGenericField__RepeatedValue__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedValue {
			(&c.FixedRepeatedValue[i]).CalculateCanotoCache()
			fieldSize := (&c.FixedRepeatedValue[i]).CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += len(canoto__NestedGenericField__FixedRepeatedValue__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			c.canotoData.size += totalSize
		}
	}
	if c.Pointer != nil {
		(c.Pointer).CalculateCanotoCache()
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			c.canotoData.size += len(canoto__NestedGenericField__Pointer__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		}
	}
	for i := range c.RepeatedPointer {
		var fieldSize int
		if c.RepeatedPointer[i] != nil {
			(c.RepeatedPointer[i]).CalculateCanotoCache()
			fieldSize = (c.RepeatedPointer[i]).CachedCanotoSize()
		}
		c.canotoData.size += len(canoto__NestedGenericField__RepeatedPointer__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedPointer {
			var fieldSize int
			if c.FixedRepeatedPointer[i] != nil {
				(c.FixedRepeatedPointer[i]).CalculateCanotoCache()
				fieldSize = (c.FixedRepeatedPointer[i]).CachedCanotoSize()
				fieldSizeSum += fieldSize
			}
			totalSize += len(canoto__NestedGenericField__FixedRepeatedPointer__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			c.canotoData.size += totalSize
		}
	}
	c.Field.CalculateCanotoCache()
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__NestedGenericField__Field__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	for i := range c.RepeatedField {
		c.RepeatedField[i].CalculateCanotoCache()
		fieldSize := c.RepeatedField[i].CachedCanotoSize()
		c.canotoData.size += len(canoto__NestedGenericField__RepeatedField__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedField {
			c.FixedRepeatedField[i].CalculateCanotoCache()
			fieldSize := c.FixedRepeatedField[i].CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += len(canoto__NestedGenericField__FixedRepeatedField__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			c.canotoData.size += totalSize
		}
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *NestedGenericField[T1, T2, T3]) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *NestedGenericField[T1, T2, T3]) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *NestedGenericField[T1, T2, T3]) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.Value).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__NestedGenericField__Value__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.Value).MarshalCanotoInto(w)
	}
	for i := range c.RepeatedValue {
		canoto.Append(&w, canoto__NestedGenericField__RepeatedValue__tag)
		canoto.AppendInt(&w, int64((&c.RepeatedValue[i]).CachedCanotoSize()))
		w = (&c.RepeatedValue[i]).MarshalCanotoInto(w)
	}
	{
		isZero := true
		for i := range c.FixedRepeatedValue {
			if (&c.FixedRepeatedValue[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedValue {
				canoto.Append(&w, canoto__NestedGenericField__FixedRepeatedValue__tag)
				canoto.AppendInt(&w, int64((&c.FixedRepeatedValue[i]).CachedCanotoSize()))
				w = (&c.FixedRepeatedValue[i]).MarshalCanotoInto(w)
			}
		}
	}
	if c.Pointer != nil {
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__NestedGenericField__Pointer__tag)
			canoto.AppendInt(&w, int64(fieldSize))
			w = (c.Pointer).MarshalCanotoInto(w)
		}
	}
	for i := range c.RepeatedPointer {
		canoto.Append(&w, canoto__NestedGenericField__RepeatedPointer__tag)
		var fieldSize int
		if c.RepeatedPointer[i] != nil {
			fieldSize = (c.RepeatedPointer[i]).CachedCanotoSize()
		}
		canoto.AppendInt(&w, int64(fieldSize))
		if fieldSize != 0 {
			w = (c.RepeatedPointer[i]).MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedPointer {
			if c.FixedRepeatedPointer[i] != nil && (c.FixedRepeatedPointer[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedPointer {
				canoto.Append(&w, canoto__NestedGenericField__FixedRepeatedPointer__tag)
				var fieldSize int
				if c.FixedRepeatedPointer[i] != nil {
					fieldSize = (c.FixedRepeatedPointer[i]).CachedCanotoSize()
				}
				canoto.AppendInt(&w, int64(fieldSize))
				if fieldSize != 0 {
					w = (c.FixedRepeatedPointer[i]).MarshalCanotoInto(w)
				}
			}
		}
	}
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__NestedGenericField__Field__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = c.Field.MarshalCanotoInto(w)
	}
	for i := range c.RepeatedField {
		canoto.Append(&w, canoto__NestedGenericField__RepeatedField__tag)
		fieldSize := c.RepeatedField[i].CachedCanotoSize()
		canoto.AppendInt(&w, int64(fieldSize))
		if fieldSize != 0 {
			w = c.RepeatedField[i].MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedField {
			if c.FixedRepeatedField[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedField {
				canoto.Append(&w, canoto__NestedGenericField__FixedRepeatedField__tag)
				fieldSize := c.FixedRepeatedField[i].CachedCanotoSize()
				canoto.AppendInt(&w, int64(fieldSize))
				if fieldSize != 0 {
					w = c.FixedRepeatedField[i].MarshalCanotoInto(w)
				}
			}
		}
	}
	return w
}

const (
	canoto__Embedded__OneOf__tag              = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__Embedded__LargestFieldNumber__tag = "\x12" // canoto.Tag(2, canoto.Len)
	canoto__Embedded__GenericField__tag       = "\x1a" // canoto.Tag(3, canoto.Len)
)

type canotoData_Embedded struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*Embedded) MakeCanoto() *Embedded {
	return new(Embedded)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *Embedded) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *Embedded) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = Embedded{}
	c.canotoData.size = len(r.B)

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.OneOf).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.LargestFieldNumber = canoto.MakePointer(c.LargestFieldNumber)
			if err := (c.LargestFieldNumber).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 3:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.GenericField = c.GenericField.MakeCanoto()
			if err := c.GenericField.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Embedded) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.OneOf).ValidCanoto() {
		return false
	}
	if c.LargestFieldNumber != nil && !(c.LargestFieldNumber).ValidCanoto() {
		return false
	}
	if !c.GenericField.ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *Embedded) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	(&c.OneOf).CalculateCanotoCache()
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__Embedded__OneOf__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	if c.LargestFieldNumber != nil {
		(c.LargestFieldNumber).CalculateCanotoCache()
		if fieldSize := (c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
			c.canotoData.size += len(canoto__Embedded__LargestFieldNumber__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		}
	}
	c.GenericField.CalculateCanotoCache()
	if fieldSize := c.GenericField.CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__Embedded__GenericField__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Embedded) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Embedded) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Embedded) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Embedded__OneOf__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.OneOf).MarshalCanotoInto(w)
	}
	if c.LargestFieldNumber != nil {
		if fieldSize := (c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Embedded__LargestFieldNumber__tag)
			canoto.AppendInt(&w, int64(fieldSize))
			w = (c.LargestFieldNumber).MarshalCanotoInto(w)
		}
	}
	if fieldSize := c.GenericField.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Embedded__GenericField__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = c.GenericField.MarshalCanotoInto(w)
	}
	return w
}

const (
	canoto__A__B_1_1C__tag = "\x08" // canoto.Tag(1, canoto.Varint)
)

type canotoData_A struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*A) MakeCanoto() *A {
	return new(A)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *A) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *A) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = A{}
	c.canotoData.size = len(r.B)

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.B__C); err != nil {
				return err
			}
			if canoto.IsZero(c.B__C) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *A) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *A) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	if !canoto.IsZero(c.B__C) {
		c.canotoData.size += len(canoto__A__B_1_1C__tag) + canoto.SizeInt(c.B__C)
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *A) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *A) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *A) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.B__C) {
		canoto.Append(&w, canoto__A__B_1_1C__tag)
		canoto.AppendInt(&w, c.B__C)
	}
	return w
}

const (
	canoto__A_1_1B__C__tag = "\x08" // canoto.Tag(1, canoto.Varint)
)

type canotoData_A__B struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*A__B) MakeCanoto() *A__B {
	return new(A__B)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *A__B) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *A__B) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = A__B{}
	c.canotoData.size = len(r.B)

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.C); err != nil {
				return err
			}
			if canoto.IsZero(c.C) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *A__B) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *A__B) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	if !canoto.IsZero(c.C) {
		c.canotoData.size += len(canoto__A_1_1B__C__tag) + canoto.SizeInt(c.C)
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *A__B) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *A__B) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *A__B) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.C) {
		canoto.Append(&w, canoto__A_1_1B__C__tag)
		canoto.AppendInt(&w, c.C)
	}
	return w
}

const (
	canoto__Scalars__Int8__tag                            = "\x08"     // canoto.Tag(1, canoto.Varint)
	canoto__Scalars__Int16__tag                           = "\x10"     // canoto.Tag(2, canoto.Varint)
	canoto__Scalars__Int32__tag                           = "\x18"     // canoto.Tag(3, canoto.Varint)
	canoto__Scalars__Int64__tag                           = "\x20"     // canoto.Tag(4, canoto.Varint)
	canoto__Scalars__Uint8__tag                           = "\x28"     // canoto.Tag(5, canoto.Varint)
	canoto__Scalars__Uint16__tag                          = "\x30"     // canoto.Tag(6, canoto.Varint)
	canoto__Scalars__Uint32__tag                          = "\x38"     // canoto.Tag(7, canoto.Varint)
	canoto__Scalars__Uint64__tag                          = "\x40"     // canoto.Tag(8, canoto.Varint)
	canoto__Scalars__Sint8__tag                           = "\x48"     // canoto.Tag(9, canoto.Varint)
	canoto__Scalars__Sint16__tag                          = "\x50"     // canoto.Tag(10, canoto.Varint)
	canoto__Scalars__Sint32__tag                          = "\x58"     // canoto.Tag(11, canoto.Varint)
	canoto__Scalars__Sint64__tag                          = "\x60"     // canoto.Tag(12, canoto.Varint)
	canoto__Scalars__Fixed32__tag                         = "\x6d"     // canoto.Tag(13, canoto.I32)
	canoto__Scalars__Fixed64__tag                         = "\x71"     // canoto.Tag(14, canoto.I64)
	canoto__Scalars__Sfixed32__tag                        = "\x7d"     // canoto.Tag(15, canoto.I32)
	canoto__Scalars__Sfixed64__tag                        = "\x81\x01" // canoto.Tag(16, canoto.I64)
	canoto__Scalars__Bool__tag                            = "\x88\x01" // canoto.Tag(17, canoto.Varint)
	canoto__Scalars__String__tag                          = "\x92\x01" // canoto.Tag(18, canoto.Len)
	canoto__Scalars__Bytes__tag                           = "\x9a\x01" // canoto.Tag(19, canoto.Len)
	canoto__Scalars__LargestFieldNumber__tag              = "\xa2\x01" // canoto.Tag(20, canoto.Len)
	canoto__Scalars__RepeatedInt8__tag                    = "\xaa\x01" // canoto.Tag(21, canoto.Len)
	canoto__Scalars__RepeatedInt16__tag                   = "\xb2\x01" // canoto.Tag(22, canoto.Len)
	canoto__Scalars__RepeatedInt32__tag                   = "\xba\x01" // canoto.Tag(23, canoto.Len)
	canoto__Scalars__RepeatedInt64__tag                   = "\xc2\x01" // canoto.Tag(24, canoto.Len)
	canoto__Scalars__RepeatedUint8__tag                   = "\xca\x01" // canoto.Tag(25, canoto.Len)
	canoto__Scalars__RepeatedUint16__tag                  = "\xd2\x01" // canoto.Tag(26, canoto.Len)
	canoto__Scalars__RepeatedUint32__tag                  = "\xda\x01" // canoto.Tag(27, canoto.Len)
	canoto__Scalars__RepeatedUint64__tag                  = "\xe2\x01" // canoto.Tag(28, canoto.Len)
	canoto__Scalars__RepeatedSint8__tag                   = "\xea\x01" // canoto.Tag(29, canoto.Len)
	canoto__Scalars__RepeatedSint16__tag                  = "\xf2\x01" // canoto.Tag(30, canoto.Len)
	canoto__Scalars__RepeatedSint32__tag                  = "\xfa\x01" // canoto.Tag(31, canoto.Len)
	canoto__Scalars__RepeatedSint64__tag                  = "\x82\x02" // canoto.Tag(32, canoto.Len)
	canoto__Scalars__RepeatedFixed32__tag                 = "\x8a\x02" // canoto.Tag(33, canoto.Len)
	canoto__Scalars__RepeatedFixed64__tag                 = "\x92\x02" // canoto.Tag(34, canoto.Len)
	canoto__Scalars__RepeatedSfixed32__tag                = "\x9a\x02" // canoto.Tag(35, canoto.Len)
	canoto__Scalars__RepeatedSfixed64__tag                = "\xa2\x02" // canoto.Tag(36, canoto.Len)
	canoto__Scalars__RepeatedBool__tag                    = "\xaa\x02" // canoto.Tag(37, canoto.Len)
	canoto__Scalars__RepeatedString__tag                  = "\xb2\x02" // canoto.Tag(38, canoto.Len)
	canoto__Scalars__RepeatedBytes__tag                   = "\xba\x02" // canoto.Tag(39, canoto.Len)
	canoto__Scalars__RepeatedLargestFieldNumber__tag      = "\xc2\x02" // canoto.Tag(40, canoto.Len)
	canoto__Scalars__FixedRepeatedInt8__tag               = "\xca\x02" // canoto.Tag(41, canoto.Len)
	canoto__Scalars__FixedRepeatedInt16__tag              = "\xd2\x02" // canoto.Tag(42, canoto.Len)
	canoto__Scalars__FixedRepeatedInt32__tag              = "\xda\x02" // canoto.Tag(43, canoto.Len)
	canoto__Scalars__FixedRepeatedInt64__tag              = "\xe2\x02" // canoto.Tag(44, canoto.Len)
	canoto__Scalars__FixedRepeatedUint8__tag              = "\xea\x02" // canoto.Tag(45, canoto.Len)
	canoto__Scalars__FixedRepeatedUint16__tag             = "\xf2\x02" // canoto.Tag(46, canoto.Len)
	canoto__Scalars__FixedRepeatedUint32__tag             = "\xfa\x02" // canoto.Tag(47, canoto.Len)
	canoto__Scalars__FixedRepeatedUint64__tag             = "\x82\x03" // canoto.Tag(48, canoto.Len)
	canoto__Scalars__FixedRepeatedSint8__tag              = "\x8a\x03" // canoto.Tag(49, canoto.Len)
	canoto__Scalars__FixedRepeatedSint16__tag             = "\x92\x03" // canoto.Tag(50, canoto.Len)
	canoto__Scalars__FixedRepeatedSint32__tag             = "\x9a\x03" // canoto.Tag(51, canoto.Len)
	canoto__Scalars__FixedRepeatedSint64__tag             = "\xa2\x03" // canoto.Tag(52, canoto.Len)
	canoto__Scalars__FixedRepeatedFixed32__tag            = "\xaa\x03" // canoto.Tag(53, canoto.Len)
	canoto__Scalars__FixedRepeatedFixed64__tag            = "\xb2\x03" // canoto.Tag(54, canoto.Len)
	canoto__Scalars__FixedRepeatedSfixed32__tag           = "\xba\x03" // canoto.Tag(55, canoto.Len)
	canoto__Scalars__FixedRepeatedSfixed64__tag           = "\xc2\x03" // canoto.Tag(56, canoto.Len)
	canoto__Scalars__FixedRepeatedBool__tag               = "\xca\x03" // canoto.Tag(57, canoto.Len)
	canoto__Scalars__FixedRepeatedString__tag             = "\xd2\x03" // canoto.Tag(58, canoto.Len)
	canoto__Scalars__FixedBytes__tag                      = "\xda\x03" // canoto.Tag(59, canoto.Len)
	canoto__Scalars__RepeatedFixedBytes__tag              = "\xe2\x03" // canoto.Tag(60, canoto.Len)
	canoto__Scalars__FixedRepeatedBytes__tag              = "\xea\x03" // canoto.Tag(61, canoto.Len)
	canoto__Scalars__FixedRepeatedFixedBytes__tag         = "\xf2\x03" // canoto.Tag(62, canoto.Len)
	canoto__Scalars__FixedRepeatedLargestFieldNumber__tag = "\xfa\x03" // canoto.Tag(63, canoto.Len)
	canoto__Scalars__ConstRepeatedUint64__tag             = "\x82\x04" // canoto.Tag(64, canoto.Len)
	canoto__Scalars__CustomType__tag                      = "\x8a\x04" // canoto.Tag(65, canoto.Len)
	canoto__Scalars__CustomUint32__tag                    = "\x95\x04" // canoto.Tag(66, canoto.I32)
	canoto__Scalars__CustomString__tag                    = "\x9a\x04" // canoto.Tag(67, canoto.Len)
	canoto__Scalars__CustomBytes__tag                     = "\xa2\x04" // canoto.Tag(68, canoto.Len)
	canoto__Scalars__CustomFixedBytes__tag                = "\xaa\x04" // canoto.Tag(69, canoto.Len)
	canoto__Scalars__CustomRepeatedBytes__tag             = "\xb2\x04" // canoto.Tag(70, canoto.Len)
	canoto__Scalars__CustomRepeatedFixedBytes__tag        = "\xba\x04" // canoto.Tag(71, canoto.Len)
	canoto__Scalars__CustomFixedRepeatedBytes__tag        = "\xc2\x04" // canoto.Tag(72, canoto.Len)
	canoto__Scalars__CustomFixedRepeatedFixedBytes__tag   = "\xca\x04" // canoto.Tag(73, canoto.Len)
	canoto__Scalars__OneOf__tag                           = "\xd2\x04" // canoto.Tag(74, canoto.Len)
	canoto__Scalars__Pointer__tag                         = "\xda\x04" // canoto.Tag(75, canoto.Len)
	canoto__Scalars__RepeatedPointer__tag                 = "\xe2\x04" // canoto.Tag(76, canoto.Len)
	canoto__Scalars__FixedRepeatedPointer__tag            = "\xea\x04" // canoto.Tag(77, canoto.Len)
	canoto__Scalars__Field__tag                           = "\xf2\x04" // canoto.Tag(78, canoto.Len)
	canoto__Scalars__RepeatedField__tag                   = "\xfa\x04" // canoto.Tag(79, canoto.Len)
	canoto__Scalars__FixedRepeatedField__tag              = "\x82\x05" // canoto.Tag(80, canoto.Len)
)

type canotoData_Scalars struct {
	size                    int
	RepeatedInt8Size        int
	RepeatedInt16Size       int
	RepeatedInt32Size       int
	RepeatedInt64Size       int
	RepeatedUint8Size       int
	RepeatedUint16Size      int
	RepeatedUint32Size      int
	RepeatedUint64Size      int
	RepeatedSint8Size       int
	RepeatedSint16Size      int
	RepeatedSint32Size      int
	RepeatedSint64Size      int
	FixedRepeatedInt8Size   int
	FixedRepeatedInt16Size  int
	FixedRepeatedInt32Size  int
	FixedRepeatedInt64Size  int
	FixedRepeatedUint8Size  int
	FixedRepeatedUint16Size int
	FixedRepeatedUint32Size int
	FixedRepeatedUint64Size int
	FixedRepeatedSint8Size  int
	FixedRepeatedSint16Size int
	FixedRepeatedSint32Size int
	FixedRepeatedSint64Size int
	ConstRepeatedUint64Size int
}

// MakeCanoto creates a new empty value.
func (*Scalars) MakeCanoto() *Scalars {
	return new(Scalars)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *Scalars) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *Scalars) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = Scalars{}
	c.canotoData.size = len(r.B)

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int8); err != nil {
				return err
			}
			if canoto.IsZero(c.Int8) {
				return canoto.ErrZeroValue
			}
		case 2:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int16); err != nil {
				return err
			}
			if canoto.IsZero(c.Int16) {
				return canoto.ErrZeroValue
			}
		case 3:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int32); err != nil {
				return err
			}
			if canoto.IsZero(c.Int32) {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int64); err != nil {
				return err
			}
			if canoto.IsZero(c.Int64) {
				return canoto.ErrZeroValue
			}
		case 5:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Uint8); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint8) {
				return canoto.ErrZeroValue
			}
		case 6:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Uint16); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint16) {
				return canoto.ErrZeroValue
			}
		case 7:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Uint32); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint32) {
				return canoto.ErrZeroValue
			}
		case 8:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Uint64); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint64) {
				return canoto.ErrZeroValue
			}
		case 9:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadSint(&r, &c.Sint8); err != nil {
				return err
			}
			if canoto.IsZero(c.Sint8) {
				return canoto.ErrZeroValue
			}
		case 10:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadSint(&r, &c.Sint16); err != nil {
				return err
			}
			if canoto.IsZero(c.Sint16) {
				return canoto.ErrZeroValue
			}
		case 11:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadSint(&r, &c.Sint32); err != nil {
				return err
			}
			if canoto.IsZero(c.Sint32) {
				return canoto.ErrZeroValue
			}
		case 12:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadSint(&r, &c.Sint64); err != nil {
				return err
			}
			if canoto.IsZero(c.Sint64) {
				return canoto.ErrZeroValue
			}
		case 13:
			if wireType != canoto.I32 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint32(&r, &c.Fixed32); err != nil {
				return err
			}
			if canoto.IsZero(c.Fixed32) {
				return canoto.ErrZeroValue
			}
		case 14:
			if wireType != canoto.I64 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint64(&r, &c.Fixed64); err != nil {
				return err
			}
			if canoto.IsZero(c.Fixed64) {
				return canoto.ErrZeroValue
			}
		case 15:
			if wireType != canoto.I32 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint32(&r, &c.Sfixed32); err != nil {
				return err
			}
			if canoto.IsZero(c.Sfixed32) {
				return canoto.ErrZeroValue
			}
		case 16:
			if wireType != canoto.I64 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint64(&r, &c.Sfixed64); err != nil {
				return err
			}
			if canoto.IsZero(c.Sfixed64) {
				return canoto.ErrZeroValue
			}
		case 17:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBool(&r, &c.Bool); err != nil {
				return err
			}
			if canoto.IsZero(c.Bool) {
				return canoto.ErrZeroValue
			}
		case 18:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadString(&r, &c.String); err != nil {
				return err
			}
			if len(c.String) == 0 {
				return canoto.ErrZeroValue
			}
		case 19:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.Bytes); err != nil {
				return err
			}
			if len(c.Bytes) == 0 {
				return canoto.ErrZeroValue
			}
		case 20:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.LargestFieldNumber).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 21:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt8 = canoto.MakeSlice(c.RepeatedInt8, canoto.CountInts(msgBytes))
			for i := range c.RepeatedInt8 {
				if err := canoto.ReadInt(&r, &c.RepeatedInt8[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedInt8Size = len(msgBytes)
		case 22:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt16 = canoto.MakeSlice(c.RepeatedInt16, canoto.CountInts(msgBytes))
			for i := range c.RepeatedInt16 {
				if err := canoto.ReadInt(&r, &c.RepeatedInt16[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedInt16Size = len(msgBytes)
		case 23:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt32 = canoto.MakeSlice(c.RepeatedInt32, canoto.CountInts(msgBytes))
			for i := range c.RepeatedInt32 {
				if err := canoto.ReadInt(&r, &c.RepeatedInt32[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedInt32Size = len(msgBytes)
		case 24:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt64 = canoto.MakeSlice(c.RepeatedInt64, canoto.CountInts(msgBytes))
			for i := range c.RepeatedInt64 {
				if err := canoto.ReadInt(&r, &c.RepeatedInt64[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedInt64Size = len(msgBytes)
		case 25:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint8 = canoto.MakeSlice(c.RepeatedUint8, canoto.CountInts(msgBytes))
			for i := range c.RepeatedUint8 {
				if err := canoto.ReadInt(&r, &c.RepeatedUint8[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedUint8Size = len(msgBytes)
		case 26:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint16 = canoto.MakeSlice(c.RepeatedUint16, canoto.CountInts(msgBytes))
			for i := range c.RepeatedUint16 {
				if err := canoto.ReadInt(&r, &c.RepeatedUint16[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedUint16Size = len(msgBytes)
		case 27:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint32 = canoto.MakeSlice(c.RepeatedUint32, canoto.CountInts(msgBytes))
			for i := range c.RepeatedUint32 {
				if err := canoto.ReadInt(&r, &c.RepeatedUint32[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedUint32Size = len(msgBytes)
		case 28:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint64 = canoto.MakeSlice(c.RepeatedUint64, canoto.CountInts(msgBytes))
			for i := range c.RepeatedUint64 {
				if err := canoto.ReadInt(&r, &c.RepeatedUint64[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedUint64Size = len(msgBytes)
		case 29:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSint8 = canoto.MakeSlice(c.RepeatedSint8, canoto.CountInts(msgBytes))
			for i := range c.RepeatedSint8 {
				if err := canoto.ReadSint(&r, &c.RepeatedSint8[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedSint8Size = len(msgBytes)
		case 30:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSint16 = canoto.MakeSlice(c.RepeatedSint16, canoto.CountInts(msgBytes))
			for i := range c.RepeatedSint16 {
				if err := canoto.ReadSint(&r, &c.RepeatedSint16[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedSint16Size = len(msgBytes)
		case 31:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSint32 = canoto.MakeSlice(c.RepeatedSint32, canoto.CountInts(msgBytes))
			for i := range c.RepeatedSint32 {
				if err := canoto.ReadSint(&r, &c.RepeatedSint32[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedSint32Size = len(msgBytes)
		case 32:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSint64 = canoto.MakeSlice(c.RepeatedSint64, canoto.CountInts(msgBytes))
			for i := range c.RepeatedSint64 {
				if err := canoto.ReadSint(&r, &c.RepeatedSint64[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedSint64Size = len(msgBytes)
		case 33:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint32 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedFixed32 = canoto.MakeSlice(c.RepeatedFixed32, int(numMsgBytes/canoto.SizeFint32))
			for i := range c.RepeatedFixed32 {
				if err := canoto.ReadFint32(&r, &c.RepeatedFixed32[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 34:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint64 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedFixed64 = canoto.MakeSlice(c.RepeatedFixed64, int(numMsgBytes/canoto.SizeFint64))
			for i := range c.RepeatedFixed64 {
				if err := canoto.ReadFint64(&r, &c.RepeatedFixed64[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 35:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint32 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSfixed32 = canoto.MakeSlice(c.RepeatedSfixed32, int(numMsgBytes/canoto.SizeFint32))
			for i := range c.RepeatedSfixed32 {
				if err := canoto.ReadFint32(&r, &c.RepeatedSfixed32[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 36:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint64 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSfixed64 = canoto.MakeSlice(c.RepeatedSfixed64, int(numMsgBytes/canoto.SizeFint64))
			for i := range c.RepeatedSfixed64 {
				if err := canoto.ReadFint64(&r, &c.RepeatedSfixed64[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 37:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeBool != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedBool = canoto.MakeSlice(c.RepeatedBool, int(numMsgBytes/canoto.SizeBool))
			for i := range c.RepeatedBool {
				if err := canoto.ReadBool(&r, &c.RepeatedBool[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 38:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedString__tag)
			if err != nil {
				return err
			}
			c.RepeatedString = canoto.MakeSlice(c.RepeatedString, countMinus1+1)

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadString(&r, &c.RepeatedString[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__RepeatedString__tag):]
				if err := canoto.ReadString(&r, &c.RepeatedString[1+i]); err != nil {
					return err
				}
			}
		case 39:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedBytes__tag)
			if err != nil {
				return err
			}
			c.RepeatedBytes = canoto.MakeSlice(c.RepeatedBytes, countMinus1+1)

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadBytes(&r, &c.RepeatedBytes[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__RepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &c.RepeatedBytes[1+i]); err != nil {
					return err
				}
			}
		case 40:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedLargestFieldNumber__tag)
			if err != nil {
				return err
			}

			c.RepeatedLargestFieldNumber = canoto.MakeSlice(c.RepeatedLargestFieldNumber, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.RepeatedLargestFieldNumber[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__RepeatedLargestFieldNumber__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.RepeatedLargestFieldNumber[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 41:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt8 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt8)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedInt8) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedInt8Size = len(msgBytes)
		case 42:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt16 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt16)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedInt16) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedInt16Size = len(msgBytes)
		case 43:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt32 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedInt32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedInt32Size = len(msgBytes)
		case 44:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt64 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedInt64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedInt64Size = len(msgBytes)
		case 45:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint8 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedUint8)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedUint8) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedUint8Size = len(msgBytes)
		case 46:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint16 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedUint16)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedUint16) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedUint16Size = len(msgBytes)
		case 47:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint32 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedUint32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedUint32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedUint32Size = len(msgBytes)
		case 48:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint64 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedUint64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedUint64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedUint64Size = len(msgBytes)
		case 49:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedSint8 {
				if err := canoto.ReadSint(&r, &(&c.FixedRepeatedSint8)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedSint8) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedSint8Size = len(msgBytes)
		case 50:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedSint16 {
				if err := canoto.ReadSint(&r, &(&c.FixedRepeatedSint16)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedSint16) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedSint16Size = len(msgBytes)
		case 51:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedSint32 {
				if err := canoto.ReadSint(&r, &(&c.FixedRepeatedSint32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedSint32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedSint32Size = len(msgBytes)
		case 52:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedSint64 {
				if err := canoto.ReadSint(&r, &(&c.FixedRepeatedSint64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedSint64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedSint64Size = len(msgBytes)
		case 53:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedFixed32 {
				if err := canoto.ReadFint32(&r, &(&c.FixedRepeatedFixed32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedFixed32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 54:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedFixed64 {
				if err := canoto.ReadFint64(&r, &(&c.FixedRepeatedFixed64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedFixed64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 55:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedSfixed32 {
				if err := canoto.ReadFint32(&r, &(&c.FixedRepeatedSfixed32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedSfixed32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 56:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedSfixed64 {
				if err := canoto.ReadFint64(&r, &(&c.FixedRepeatedSfixed64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedSfixed64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 57:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedBool {
				if err := canoto.ReadBool(&r, &(&c.FixedRepeatedBool)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.FixedRepeatedBool) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 58:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			if err := canoto.ReadString(&r, &(&c.FixedRepeatedString)[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			isZero := len((&c.FixedRepeatedString)[0]) == 0
			const numToRead = uint(len(c.FixedRepeatedString) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedString__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedString__tag):]
				if err := canoto.ReadString(&r, &(&c.FixedRepeatedString)[1+i]); err != nil {
					return err
				}
				isZero = isZero && len((&c.FixedRepeatedString)[1+i]) == 0
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 59:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength      = len(c.FixedBytes)
				expectedLengthInt64 = int64(expectedLength)
			)
			var length int64
			if err := canoto.ReadInt(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthInt64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy((&c.FixedBytes)[:], r.B)
			if canoto.IsZero(c.FixedBytes) {
				return canoto.ErrZeroValue
			}
			r.B = r.B[expectedLength:]
		case 60:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength      = len(c.RepeatedFixedBytes[0])
				expectedLengthInt64 = int64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length int64
			if err := canoto.ReadInt(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthInt64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			firstEntry := r.B[:expectedLength]
			r.B = r.B[expectedLength:]

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedFixedBytes__tag)
			if err != nil {
				return err
			}

			c.RepeatedFixedBytes = canoto.MakeSlice(c.RepeatedFixedBytes, countMinus1+1)
			copy((&c.RepeatedFixedBytes[0])[:], firstEntry)

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__RepeatedFixedBytes__tag):]
				if err := canoto.ReadInt(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthInt64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				copy((&c.RepeatedFixedBytes[1+i])[:], r.B)
				r.B = r.B[expectedLength:]
			}
		case 61:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			if err := canoto.ReadBytes(&r, &(&c.FixedRepeatedBytes)[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			isZero := len((&c.FixedRepeatedBytes)[0]) == 0
			const numToRead = uint(len(c.FixedRepeatedBytes) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &(&c.FixedRepeatedBytes)[1+i]); err != nil {
					return err
				}
				isZero = isZero && len((&c.FixedRepeatedBytes)[1+i]) == 0
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 62:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength      = len(c.FixedRepeatedFixedBytes[0])
				expectedLengthInt64 = int64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length int64
			if err := canoto.ReadInt(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthInt64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy((&(&c.FixedRepeatedFixedBytes)[0])[:], r.B)
			r.B = r.B[expectedLength:]

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedFixedBytes) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedFixedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedFixedBytes__tag):]

				if err := canoto.ReadInt(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthInt64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				copy((&(&c.FixedRepeatedFixedBytes)[1+i])[:], r.B)
				r.B = r.B[expectedLength:]
			}
			if canoto.IsZero(c.FixedRepeatedFixedBytes) {
				return canoto.ErrZeroValue
			}
		case 63:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.FixedRepeatedLargestFieldNumber[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedLargestFieldNumber) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedLargestFieldNumber__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedLargestFieldNumber__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.FixedRepeatedLargestFieldNumber[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 64:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.ConstRepeatedUint64 {
				if err := canoto.ReadInt(&r, &(&c.ConstRepeatedUint64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return io.ErrUnexpectedEOF
			}
			if canoto.IsZero(c.ConstRepeatedUint64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.ConstRepeatedUint64Size = len(msgBytes)
		case 65:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.CustomType).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 66:
			if wireType != canoto.I32 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint32(&r, &c.CustomUint32); err != nil {
				return err
			}
			if canoto.IsZero(c.CustomUint32) {
				return canoto.ErrZeroValue
			}
		case 67:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadString(&r, &c.CustomString); err != nil {
				return err
			}
			if len(c.CustomString) == 0 {
				return canoto.ErrZeroValue
			}
		case 68:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.CustomBytes); err != nil {
				return err
			}
			if len(c.CustomBytes) == 0 {
				return canoto.ErrZeroValue
			}
		case 69:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength      = len(c.CustomFixedBytes)
				expectedLengthInt64 = int64(expectedLength)
			)
			var length int64
			if err := canoto.ReadInt(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthInt64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy((&c.CustomFixedBytes)[:], r.B)
			if canoto.IsZero(c.CustomFixedBytes) {
				return canoto.ErrZeroValue
			}
			r.B = r.B[expectedLength:]
		case 70:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__CustomRepeatedBytes__tag)
			if err != nil {
				return err
			}
			c.CustomRepeatedBytes = canoto.MakeSlice(c.CustomRepeatedBytes, countMinus1+1)

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadBytes(&r, &c.CustomRepeatedBytes[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__CustomRepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &c.CustomRepeatedBytes[1+i]); err != nil {
					return err
				}
			}
		case 71:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength      = len(c.CustomRepeatedFixedBytes[0])
				expectedLengthInt64 = int64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length int64
			if err := canoto.ReadInt(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthInt64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			firstEntry := r.B[:expectedLength]
			r.B = r.B[expectedLength:]

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__CustomRepeatedFixedBytes__tag)
			if err != nil {
				return err
			}

			c.CustomRepeatedFixedBytes = canoto.MakeSlice(c.CustomRepeatedFixedBytes, countMinus1+1)
			copy((&c.CustomRepeatedFixedBytes[0])[:], firstEntry)

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__CustomRepeatedFixedBytes__tag):]
				if err := canoto.ReadInt(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthInt64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				copy((&c.CustomRepeatedFixedBytes[1+i])[:], r.B)
				r.B = r.B[expectedLength:]
			}
		case 72:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			if err := canoto.ReadBytes(&r, &(&c.CustomFixedRepeatedBytes)[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			isZero := len((&c.CustomFixedRepeatedBytes)[0]) == 0
			const numToRead = uint(len(c.CustomFixedRepeatedBytes) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__CustomFixedRepeatedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__CustomFixedRepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &(&c.CustomFixedRepeatedBytes)[1+i]); err != nil {
					return err
				}
				isZero = isZero && len((&c.CustomFixedRepeatedBytes)[1+i]) == 0
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 73:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength      = len(c.CustomFixedRepeatedFixedBytes[0])
				expectedLengthInt64 = int64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length int64
			if err := canoto.ReadInt(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthInt64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy((&(&c.CustomFixedRepeatedFixedBytes)[0])[:], r.B)
			r.B = r.B[expectedLength:]

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.CustomFixedRepeatedFixedBytes) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__CustomFixedRepeatedFixedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__CustomFixedRepeatedFixedBytes__tag):]

				if err := canoto.ReadInt(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthInt64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				copy((&(&c.CustomFixedRepeatedFixedBytes)[1+i])[:], r.B)
				r.B = r.B[expectedLength:]
			}
			if canoto.IsZero(c.CustomFixedRepeatedFixedBytes) {
				return canoto.ErrZeroValue
			}
		case 74:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.OneOf).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 75:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Pointer = canoto.MakePointer(c.Pointer)
			if err := (c.Pointer).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 76:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedPointer__tag)
			if err != nil {
				return err
			}

			c.RepeatedPointer = canoto.MakeSlice(c.RepeatedPointer, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedPointer[0] = canoto.MakePointer(c.RepeatedPointer[0])
				if err := (c.RepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__RepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedPointer[1+i] = canoto.MakePointer(c.RepeatedPointer[1+i])
				if err := (c.RepeatedPointer[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 77:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			c.FixedRepeatedPointer[0] = nil
			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[0] = canoto.MakePointer(c.FixedRepeatedPointer[0])
				if err := (c.FixedRepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedPointer) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedPointer__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					c.FixedRepeatedPointer[1+i] = nil
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[1+i] = canoto.MakePointer(c.FixedRepeatedPointer[1+i])
				if err := (c.FixedRepeatedPointer[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 78:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Field = c.Field.MakeCanoto()
			if err := c.Field.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 79:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedField__tag)
			if err != nil {
				return err
			}

			c.RepeatedField = canoto.MakeSlice(c.RepeatedField, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedField[0] = c.RepeatedField[0].MakeCanoto()
				if err := c.RepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__RepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedField[1+i] = c.RepeatedField[1+i].MakeCanoto()
				if err := c.RepeatedField[1+i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 80:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			c.FixedRepeatedField[0] = canoto.Zero(c.FixedRepeatedField[0])
			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[0] = c.FixedRepeatedField[0].MakeCanoto()
				if err := c.FixedRepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedField) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedField__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					c.FixedRepeatedField[1+i] = canoto.Zero(c.FixedRepeatedField[1+i])
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[1+i] = c.FixedRepeatedField[1+i].MakeCanoto()
				if err := c.FixedRepeatedField[1+i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Scalars) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !utf8.ValidString(string(c.String)) {
		return false
	}
	if !(&c.LargestFieldNumber).ValidCanoto() {
		return false
	}
	for _, v := range c.RepeatedString {
		if !utf8.ValidString(string(v)) {
			return false
		}
	}
	for i := range c.RepeatedLargestFieldNumber {
		if !(&c.RepeatedLargestFieldNumber[i]).ValidCanoto() {
			return false
		}
	}
	for _, v := range &c.FixedRepeatedString {
		if !utf8.ValidString(string(v)) {
			return false
		}
	}
	for i := range &c.FixedRepeatedLargestFieldNumber {
		if !(&(&c.FixedRepeatedLargestFieldNumber)[i]).ValidCanoto() {
			return false
		}
	}
	if !(&c.CustomType).ValidCanoto() {
		return false
	}
	if !utf8.ValidString(string(c.CustomString)) {
		return false
	}
	if !(&c.OneOf).ValidCanoto() {
		return false
	}
	if c.Pointer != nil && !(c.Pointer).ValidCanoto() {
		return false
	}
	for i := range c.RepeatedPointer {
		if c.RepeatedPointer[i] != nil && !(c.RepeatedPointer[i]).ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedPointer {
		if (&c.FixedRepeatedPointer)[i] != nil && !((&c.FixedRepeatedPointer)[i]).ValidCanoto() {
			return false
		}
	}
	if !c.Field.ValidCanoto() {
		return false
	}
	for i := range c.RepeatedField {
		if !c.RepeatedField[i].ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedField {
		if !(&c.FixedRepeatedField)[i].ValidCanoto() {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *Scalars) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	if !canoto.IsZero(c.Int8) {
		c.canotoData.size += len(canoto__Scalars__Int8__tag) + canoto.SizeInt(c.Int8)
	}
	if !canoto.IsZero(c.Int16) {
		c.canotoData.size += len(canoto__Scalars__Int16__tag) + canoto.SizeInt(c.Int16)
	}
	if !canoto.IsZero(c.Int32) {
		c.canotoData.size += len(canoto__Scalars__Int32__tag) + canoto.SizeInt(c.Int32)
	}
	if !canoto.IsZero(c.Int64) {
		c.canotoData.size += len(canoto__Scalars__Int64__tag) + canoto.SizeInt(c.Int64)
	}
	if !canoto.IsZero(c.Uint8) {
		c.canotoData.size += len(canoto__Scalars__Uint8__tag) + canoto.SizeInt(c.Uint8)
	}
	if !canoto.IsZero(c.Uint16) {
		c.canotoData.size += len(canoto__Scalars__Uint16__tag) + canoto.SizeInt(c.Uint16)
	}
	if !canoto.IsZero(c.Uint32) {
		c.canotoData.size += len(canoto__Scalars__Uint32__tag) + canoto.SizeInt(c.Uint32)
	}
	if !canoto.IsZero(c.Uint64) {
		c.canotoData.size += len(canoto__Scalars__Uint64__tag) + canoto.SizeInt(c.Uint64)
	}
	if !canoto.IsZero(c.Sint8) {
		c.canotoData.size += len(canoto__Scalars__Sint8__tag) + canoto.SizeSint(c.Sint8)
	}
	if !canoto.IsZero(c.Sint16) {
		c.canotoData.size += len(canoto__Scalars__Sint16__tag) + canoto.SizeSint(c.Sint16)
	}
	if !canoto.IsZero(c.Sint32) {
		c.canotoData.size += len(canoto__Scalars__Sint32__tag) + canoto.SizeSint(c.Sint32)
	}
	if !canoto.IsZero(c.Sint64) {
		c.canotoData.size += len(canoto__Scalars__Sint64__tag) + canoto.SizeSint(c.Sint64)
	}
	if !canoto.IsZero(c.Fixed32) {
		c.canotoData.size += len(canoto__Scalars__Fixed32__tag) + canoto.SizeFint32
	}
	if !canoto.IsZero(c.Fixed64) {
		c.canotoData.size += len(canoto__Scalars__Fixed64__tag) + canoto.SizeFint64
	}
	if !canoto.IsZero(c.Sfixed32) {
		c.canotoData.size += len(canoto__Scalars__Sfixed32__tag) + canoto.SizeFint32
	}
	if !canoto.IsZero(c.Sfixed64) {
		c.canotoData.size += len(canoto__Scalars__Sfixed64__tag) + canoto.SizeFint64
	}
	if !canoto.IsZero(c.Bool) {
		c.canotoData.size += len(canoto__Scalars__Bool__tag) + canoto.SizeBool
	}
	if len(c.String) != 0 {
		c.canotoData.size += len(canoto__Scalars__String__tag) + canoto.SizeBytes(c.String)
	}
	if len(c.Bytes) != 0 {
		c.canotoData.size += len(canoto__Scalars__Bytes__tag) + canoto.SizeBytes(c.Bytes)
	}
	(&c.LargestFieldNumber).CalculateCanotoCache()
	if fieldSize := (&c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__Scalars__LargestFieldNumber__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	if len(c.RepeatedInt8) != 0 {
		c.canotoData.RepeatedInt8Size = 0
		for _, v := range c.RepeatedInt8 {
			c.canotoData.RepeatedInt8Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__RepeatedInt8__tag) + canoto.SizeInt(int64(c.canotoData.RepeatedInt8Size)) + c.canotoData.RepeatedInt8Size
	}
	if len(c.RepeatedInt16) != 0 {
		c.canotoData.RepeatedInt16Size = 0
		for _, v := range c.RepeatedInt16 {
			c.canotoData.RepeatedInt16Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__RepeatedInt16__tag) + canoto.SizeInt(int64(c.canotoData.RepeatedInt16Size)) + c.canotoData.RepeatedInt16Size
	}
	if len(c.RepeatedInt32) != 0 {
		c.canotoData.RepeatedInt32Size = 0
		for _, v := range c.RepeatedInt32 {
			c.canotoData.RepeatedInt32Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__RepeatedInt32__tag) + canoto.SizeInt(int64(c.canotoData.RepeatedInt32Size)) + c.canotoData.RepeatedInt32Size
	}
	if len(c.RepeatedInt64) != 0 {
		c.canotoData.RepeatedInt64Size = 0
		for _, v := range c.RepeatedInt64 {
			c.canotoData.RepeatedInt64Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__RepeatedInt64__tag) + canoto.SizeInt(int64(c.canotoData.RepeatedInt64Size)) + c.canotoData.RepeatedInt64Size
	}
	if len(c.RepeatedUint8) != 0 {
		c.canotoData.RepeatedUint8Size = 0
		for _, v := range c.RepeatedUint8 {
			c.canotoData.RepeatedUint8Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__RepeatedUint8__tag) + canoto.SizeInt(int64(c.canotoData.RepeatedUint8Size)) + c.canotoData.RepeatedUint8Size
	}
	if len(c.RepeatedUint16) != 0 {
		c.canotoData.RepeatedUint16Size = 0
		for _, v := range c.RepeatedUint16 {
			c.canotoData.RepeatedUint16Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__RepeatedUint16__tag) + canoto.SizeInt(int64(c.canotoData.RepeatedUint16Size)) + c.canotoData.RepeatedUint16Size
	}
	if len(c.RepeatedUint32) != 0 {
		c.canotoData.RepeatedUint32Size = 0
		for _, v := range c.RepeatedUint32 {
			c.canotoData.RepeatedUint32Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__RepeatedUint32__tag) + canoto.SizeInt(int64(c.canotoData.RepeatedUint32Size)) + c.canotoData.RepeatedUint32Size
	}
	if len(c.RepeatedUint64) != 0 {
		c.canotoData.RepeatedUint64Size = 0
		for _, v := range c.RepeatedUint64 {
			c.canotoData.RepeatedUint64Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__RepeatedUint64__tag) + canoto.SizeInt(int64(c.canotoData.RepeatedUint64Size)) + c.canotoData.RepeatedUint64Size
	}
	if len(c.RepeatedSint8) != 0 {
		c.canotoData.RepeatedSint8Size = 0
		for _, v := range c.RepeatedSint8 {
			c.canotoData.RepeatedSint8Size += canoto.SizeSint(v)
		}
		c.canotoData.size += len(canoto__Scalars__RepeatedSint8__tag) + canoto.SizeInt(int64(c.canotoData.RepeatedSint8Size)) + c.canotoData.RepeatedSint8Size
	}
	if len(c.RepeatedSint16) != 0 {
		c.canotoData.RepeatedSint16Size = 0
		for _, v := range c.RepeatedSint16 {
			c.canotoData.RepeatedSint16Size += canoto.SizeSint(v)
		}
		c.canotoData.size += len(canoto__Scalars__RepeatedSint16__tag) + canoto.SizeInt(int64(c.canotoData.RepeatedSint16Size)) + c.canotoData.RepeatedSint16Size
	}
	if len(c.RepeatedSint32) != 0 {
		c.canotoData.RepeatedSint32Size = 0
		for _, v := range c.RepeatedSint32 {
			c.canotoData.RepeatedSint32Size += canoto.SizeSint(v)
		}
		c.canotoData.size += len(canoto__Scalars__RepeatedSint32__tag) + canoto.SizeInt(int64(c.canotoData.RepeatedSint32Size)) + c.canotoData.RepeatedSint32Size
	}
	if len(c.RepeatedSint64) != 0 {
		c.canotoData.RepeatedSint64Size = 0
		for _, v := range c.RepeatedSint64 {
			c.canotoData.RepeatedSint64Size += canoto.SizeSint(v)
		}
		c.canotoData.size += len(canoto__Scalars__RepeatedSint64__tag) + canoto.SizeInt(int64(c.canotoData.RepeatedSint64Size)) + c.canotoData.RepeatedSint64Size
	}
	if num := len(c.RepeatedFixed32); num != 0 {
		fieldSize := num * canoto.SizeFint32
		c.canotoData.size += len(canoto__Scalars__RepeatedFixed32__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	if num := len(c.RepeatedFixed64); num != 0 {
		fieldSize := num * canoto.SizeFint64
		c.canotoData.size += len(canoto__Scalars__RepeatedFixed64__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	if num := len(c.RepeatedSfixed32); num != 0 {
		fieldSize := num * canoto.SizeFint32
		c.canotoData.size += len(canoto__Scalars__RepeatedSfixed32__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	if num := len(c.RepeatedSfixed64); num != 0 {
		fieldSize := num * canoto.SizeFint64
		c.canotoData.size += len(canoto__Scalars__RepeatedSfixed64__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	if num := len(c.RepeatedBool); num != 0 {
		fieldSize := num * canoto.SizeBool
		c.canotoData.size += len(canoto__Scalars__RepeatedBool__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	for _, v := range c.RepeatedString {
		c.canotoData.size += len(canoto__Scalars__RepeatedString__tag) + canoto.SizeBytes(v)
	}
	for _, v := range c.RepeatedBytes {
		c.canotoData.size += len(canoto__Scalars__RepeatedBytes__tag) + canoto.SizeBytes(v)
	}
	for i := range c.RepeatedLargestFieldNumber {
		(&c.RepeatedLargestFieldNumber[i]).CalculateCanotoCache()
		fieldSize := (&c.RepeatedLargestFieldNumber[i]).CachedCanotoSize()
		c.canotoData.size += len(canoto__Scalars__RepeatedLargestFieldNumber__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	if !canoto.IsZero(c.FixedRepeatedInt8) {
		c.canotoData.FixedRepeatedInt8Size = 0
		for _, v := range &c.FixedRepeatedInt8 {
			c.canotoData.FixedRepeatedInt8Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedInt8__tag) + canoto.SizeInt(int64(c.canotoData.FixedRepeatedInt8Size)) + c.canotoData.FixedRepeatedInt8Size
	}
	if !canoto.IsZero(c.FixedRepeatedInt16) {
		c.canotoData.FixedRepeatedInt16Size = 0
		for _, v := range &c.FixedRepeatedInt16 {
			c.canotoData.FixedRepeatedInt16Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedInt16__tag) + canoto.SizeInt(int64(c.canotoData.FixedRepeatedInt16Size)) + c.canotoData.FixedRepeatedInt16Size
	}
	if !canoto.IsZero(c.FixedRepeatedInt32) {
		c.canotoData.FixedRepeatedInt32Size = 0
		for _, v := range &c.FixedRepeatedInt32 {
			c.canotoData.FixedRepeatedInt32Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedInt32__tag) + canoto.SizeInt(int64(c.canotoData.FixedRepeatedInt32Size)) + c.canotoData.FixedRepeatedInt32Size
	}
	if !canoto.IsZero(c.FixedRepeatedInt64) {
		c.canotoData.FixedRepeatedInt64Size = 0
		for _, v := range &c.FixedRepeatedInt64 {
			c.canotoData.FixedRepeatedInt64Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedInt64__tag) + canoto.SizeInt(int64(c.canotoData.FixedRepeatedInt64Size)) + c.canotoData.FixedRepeatedInt64Size
	}
	if !canoto.IsZero(c.FixedRepeatedUint8) {
		c.canotoData.FixedRepeatedUint8Size = 0
		for _, v := range &c.FixedRepeatedUint8 {
			c.canotoData.FixedRepeatedUint8Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedUint8__tag) + canoto.SizeInt(int64(c.canotoData.FixedRepeatedUint8Size)) + c.canotoData.FixedRepeatedUint8Size
	}
	if !canoto.IsZero(c.FixedRepeatedUint16) {
		c.canotoData.FixedRepeatedUint16Size = 0
		for _, v := range &c.FixedRepeatedUint16 {
			c.canotoData.FixedRepeatedUint16Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedUint16__tag) + canoto.SizeInt(int64(c.canotoData.FixedRepeatedUint16Size)) + c.canotoData.FixedRepeatedUint16Size
	}
	if !canoto.IsZero(c.FixedRepeatedUint32) {
		c.canotoData.FixedRepeatedUint32Size = 0
		for _, v := range &c.FixedRepeatedUint32 {
			c.canotoData.FixedRepeatedUint32Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedUint32__tag) + canoto.SizeInt(int64(c.canotoData.FixedRepeatedUint32Size)) + c.canotoData.FixedRepeatedUint32Size
	}
	if !canoto.IsZero(c.FixedRepeatedUint64) {
		c.canotoData.FixedRepeatedUint64Size = 0
		for _, v := range &c.FixedRepeatedUint64 {
			c.canotoData.FixedRepeatedUint64Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedUint64__tag) + canoto.SizeInt(int64(c.canotoData.FixedRepeatedUint64Size)) + c.canotoData.FixedRepeatedUint64Size
	}
	if !canoto.IsZero(c.FixedRepeatedSint8) {
		c.canotoData.FixedRepeatedSint8Size = 0
		for _, v := range &c.FixedRepeatedSint8 {
			c.canotoData.FixedRepeatedSint8Size += canoto.SizeSint(v)
		}
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedSint8__tag) + canoto.SizeInt(int64(c.canotoData.FixedRepeatedSint8Size)) + c.canotoData.FixedRepeatedSint8Size
	}
	if !canoto.IsZero(c.FixedRepeatedSint16) {
		c.canotoData.FixedRepeatedSint16Size = 0
		for _, v := range &c.FixedRepeatedSint16 {
			c.canotoData.FixedRepeatedSint16Size += canoto.SizeSint(v)
		}
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedSint16__tag) + canoto.SizeInt(int64(c.canotoData.FixedRepeatedSint16Size)) + c.canotoData.FixedRepeatedSint16Size
	}
	if !canoto.IsZero(c.FixedRepeatedSint32) {
		c.canotoData.FixedRepeatedSint32Size = 0
		for _, v := range &c.FixedRepeatedSint32 {
			c.canotoData.FixedRepeatedSint32Size += canoto.SizeSint(v)
		}
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedSint32__tag) + canoto.SizeInt(int64(c.canotoData.FixedRepeatedSint32Size)) + c.canotoData.FixedRepeatedSint32Size
	}
	if !canoto.IsZero(c.FixedRepeatedSint64) {
		c.canotoData.FixedRepeatedSint64Size = 0
		for _, v := range &c.FixedRepeatedSint64 {
			c.canotoData.FixedRepeatedSint64Size += canoto.SizeSint(v)
		}
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedSint64__tag) + canoto.SizeInt(int64(c.canotoData.FixedRepeatedSint64Size)) + c.canotoData.FixedRepeatedSint64Size
	}
	if !canoto.IsZero(c.FixedRepeatedFixed32) {
		const fieldSize = len(c.FixedRepeatedFixed32) * canoto.SizeFint32
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedFixed32__tag) + fieldSize + canoto.SizeInt(int64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedFixed64) {
		const fieldSize = len(c.FixedRepeatedFixed64) * canoto.SizeFint64
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedFixed64__tag) + fieldSize + canoto.SizeInt(int64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed32) {
		const fieldSize = len(c.FixedRepeatedSfixed32) * canoto.SizeFint32
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedSfixed32__tag) + fieldSize + canoto.SizeInt(int64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed64) {
		const fieldSize = len(c.FixedRepeatedSfixed64) * canoto.SizeFint64
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedSfixed64__tag) + fieldSize + canoto.SizeInt(int64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedBool) {
		const fieldSize = len(c.FixedRepeatedBool) * canoto.SizeBool
		c.canotoData.size += len(canoto__Scalars__FixedRepeatedBool__tag) + fieldSize + canoto.SizeInt(int64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedString) {
		for _, v := range &c.FixedRepeatedString {
			c.canotoData.size += len(canoto__Scalars__FixedRepeatedString__tag) + canoto.SizeBytes(v)
		}
	}
	if !canoto.IsZero(c.FixedBytes) {
		c.canotoData.size += len(canoto__Scalars__FixedBytes__tag) + canoto.SizeBytes((&c.FixedBytes)[:])
	}
	if num := len(c.RepeatedFixedBytes); num != 0 {
		fieldSize := len(canoto__Scalars__RepeatedFixedBytes__tag) + canoto.SizeBytes((&c.RepeatedFixedBytes[0])[:])
		c.canotoData.size += num * fieldSize
	}
	{
		isZero := true
		for _, v := range c.FixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.FixedRepeatedBytes {
				c.canotoData.size += len(canoto__Scalars__FixedRepeatedBytes__tag) + canoto.SizeBytes(v)
			}
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixedBytes) {
		for i := range c.FixedRepeatedFixedBytes {
			c.canotoData.size += len(canoto__Scalars__FixedRepeatedFixedBytes__tag) + canoto.SizeBytes((&(&c.FixedRepeatedFixedBytes)[i])[:])
		}
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedLargestFieldNumber {
			(&c.FixedRepeatedLargestFieldNumber[i]).CalculateCanotoCache()
			fieldSize := (&c.FixedRepeatedLargestFieldNumber[i]).CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += len(canoto__Scalars__FixedRepeatedLargestFieldNumber__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			c.canotoData.size += totalSize
		}
	}
	if !canoto.IsZero(c.ConstRepeatedUint64) {
		c.canotoData.ConstRepeatedUint64Size = 0
		for _, v := range &c.ConstRepeatedUint64 {
			c.canotoData.ConstRepeatedUint64Size += canoto.SizeInt(v)
		}
		c.canotoData.size += len(canoto__Scalars__ConstRepeatedUint64__tag) + canoto.SizeInt(int64(c.canotoData.ConstRepeatedUint64Size)) + c.canotoData.ConstRepeatedUint64Size
	}
	(&c.CustomType).CalculateCanotoCache()
	if fieldSize := (&c.CustomType).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__Scalars__CustomType__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	if !canoto.IsZero(c.CustomUint32) {
		c.canotoData.size += len(canoto__Scalars__CustomUint32__tag) + canoto.SizeFint32
	}
	if len(c.CustomString) != 0 {
		c.canotoData.size += len(canoto__Scalars__CustomString__tag) + canoto.SizeBytes(c.CustomString)
	}
	if len(c.CustomBytes) != 0 {
		c.canotoData.size += len(canoto__Scalars__CustomBytes__tag) + canoto.SizeBytes(c.CustomBytes)
	}
	if !canoto.IsZero(c.CustomFixedBytes) {
		c.canotoData.size += len(canoto__Scalars__CustomFixedBytes__tag) + canoto.SizeBytes((&c.CustomFixedBytes)[:])
	}
	for _, v := range c.CustomRepeatedBytes {
		c.canotoData.size += len(canoto__Scalars__CustomRepeatedBytes__tag) + canoto.SizeBytes(v)
	}
	if num := len(c.CustomRepeatedFixedBytes); num != 0 {
		fieldSize := len(canoto__Scalars__CustomRepeatedFixedBytes__tag) + canoto.SizeBytes((&c.CustomRepeatedFixedBytes[0])[:])
		c.canotoData.size += num * fieldSize
	}
	{
		isZero := true
		for _, v := range c.CustomFixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.CustomFixedRepeatedBytes {
				c.canotoData.size += len(canoto__Scalars__CustomFixedRepeatedBytes__tag) + canoto.SizeBytes(v)
			}
		}
	}
	if !canoto.IsZero(c.CustomFixedRepeatedFixedBytes) {
		for i := range c.CustomFixedRepeatedFixedBytes {
			c.canotoData.size += len(canoto__Scalars__CustomFixedRepeatedFixedBytes__tag) + canoto.SizeBytes((&(&c.CustomFixedRepeatedFixedBytes)[i])[:])
		}
	}
	(&c.OneOf).CalculateCanotoCache()
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__Scalars__OneOf__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	if c.Pointer != nil {
		(c.Pointer).CalculateCanotoCache()
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			c.canotoData.size += len(canoto__Scalars__Pointer__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		}
	}
	for i := range c.RepeatedPointer {
		var fieldSize int
		if c.RepeatedPointer[i] != nil {
			(c.RepeatedPointer[i]).CalculateCanotoCache()
			fieldSize = (c.RepeatedPointer[i]).CachedCanotoSize()
		}
		c.canotoData.size += len(canoto__Scalars__RepeatedPointer__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedPointer {
			var fieldSize int
			if c.FixedRepeatedPointer[i] != nil {
				(c.FixedRepeatedPointer[i]).CalculateCanotoCache()
				fieldSize = (c.FixedRepeatedPointer[i]).CachedCanotoSize()
				fieldSizeSum += fieldSize
			}
			totalSize += len(canoto__Scalars__FixedRepeatedPointer__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			c.canotoData.size += totalSize
		}
	}
	c.Field.CalculateCanotoCache()
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__Scalars__Field__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	for i := range c.RepeatedField {
		c.RepeatedField[i].CalculateCanotoCache()
		fieldSize := c.RepeatedField[i].CachedCanotoSize()
		c.canotoData.size += len(canoto__Scalars__RepeatedField__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedField {
			c.FixedRepeatedField[i].CalculateCanotoCache()
			fieldSize := c.FixedRepeatedField[i].CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += len(canoto__Scalars__FixedRepeatedField__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			c.canotoData.size += totalSize
		}
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Scalars) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Scalars) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Scalars) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Int8) {
		canoto.Append(&w, canoto__Scalars__Int8__tag)
		canoto.AppendInt(&w, c.Int8)
	}
	if !canoto.IsZero(c.Int16) {
		canoto.Append(&w, canoto__Scalars__Int16__tag)
		canoto.AppendInt(&w, c.Int16)
	}
	if !canoto.IsZero(c.Int32) {
		canoto.Append(&w, canoto__Scalars__Int32__tag)
		canoto.AppendInt(&w, c.Int32)
	}
	if !canoto.IsZero(c.Int64) {
		canoto.Append(&w, canoto__Scalars__Int64__tag)
		canoto.AppendInt(&w, c.Int64)
	}
	if !canoto.IsZero(c.Uint8) {
		canoto.Append(&w, canoto__Scalars__Uint8__tag)
		canoto.AppendInt(&w, c.Uint8)
	}
	if !canoto.IsZero(c.Uint16) {
		canoto.Append(&w, canoto__Scalars__Uint16__tag)
		canoto.AppendInt(&w, c.Uint16)
	}
	if !canoto.IsZero(c.Uint32) {
		canoto.Append(&w, canoto__Scalars__Uint32__tag)
		canoto.AppendInt(&w, c.Uint32)
	}
	if !canoto.IsZero(c.Uint64) {
		canoto.Append(&w, canoto__Scalars__Uint64__tag)
		canoto.AppendInt(&w, c.Uint64)
	}
	if !canoto.IsZero(c.Sint8) {
		canoto.Append(&w, canoto__Scalars__Sint8__tag)
		canoto.AppendSint(&w, c.Sint8)
	}
	if !canoto.IsZero(c.Sint16) {
		canoto.Append(&w, canoto__Scalars__Sint16__tag)
		canoto.AppendSint(&w, c.Sint16)
	}
	if !canoto.IsZero(c.Sint32) {
		canoto.Append(&w, canoto__Scalars__Sint32__tag)
		canoto.AppendSint(&w, c.Sint32)
	}
	if !canoto.IsZero(c.Sint64) {
		canoto.Append(&w, canoto__Scalars__Sint64__tag)
		canoto.AppendSint(&w, c.Sint64)
	}
	if !canoto.IsZero(c.Fixed32) {
		canoto.Append(&w, canoto__Scalars__Fixed32__tag)
		canoto.AppendFint32(&w, c.Fixed32)
	}
	if !canoto.IsZero(c.Fixed64) {
		canoto.Append(&w, canoto__Scalars__Fixed64__tag)
		canoto.AppendFint64(&w, c.Fixed64)
	}
	if !canoto.IsZero(c.Sfixed32) {
		canoto.Append(&w, canoto__Scalars__Sfixed32__tag)
		canoto.AppendFint32(&w, c.Sfixed32)
	}
	if !canoto.IsZero(c.Sfixed64) {
		canoto.Append(&w, canoto__Scalars__Sfixed64__tag)
		canoto.AppendFint64(&w, c.Sfixed64)
	}
	if !canoto.IsZero(c.Bool) {
		canoto.Append(&w, canoto__Scalars__Bool__tag)
		canoto.AppendBool(&w, true)
	}
	if len(c.String) != 0 {
		canoto.Append(&w, canoto__Scalars__String__tag)
		canoto.AppendBytes(&w, c.String)
	}
	if len(c.Bytes) != 0 {
		canoto.Append(&w, canoto__Scalars__Bytes__tag)
		canoto.AppendBytes(&w, c.Bytes)
	}
	if fieldSize := (&c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__LargestFieldNumber__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.LargestFieldNumber).MarshalCanotoInto(w)
	}
	if len(c.RepeatedInt8) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt8__tag)
		canoto.AppendInt(&w, int64(c.canotoData.RepeatedInt8Size))
		for _, v := range c.RepeatedInt8 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt16) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt16__tag)
		canoto.AppendInt(&w, int64(c.canotoData.RepeatedInt16Size))
		for _, v := range c.RepeatedInt16 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt32) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt32__tag)
		canoto.AppendInt(&w, int64(c.canotoData.RepeatedInt32Size))
		for _, v := range c.RepeatedInt32 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt64) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt64__tag)
		canoto.AppendInt(&w, int64(c.canotoData.RepeatedInt64Size))
		for _, v := range c.RepeatedInt64 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedUint8) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint8__tag)
		canoto.AppendInt(&w, int64(c.canotoData.RepeatedUint8Size))
		for _, v := range c.RepeatedUint8 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedUint16) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint16__tag)
		canoto.AppendInt(&w, int64(c.canotoData.RepeatedUint16Size))
		for _, v := range c.RepeatedUint16 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedUint32) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint32__tag)
		canoto.AppendInt(&w, int64(c.canotoData.RepeatedUint32Size))
		for _, v := range c.RepeatedUint32 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedUint64) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint64__tag)
		canoto.AppendInt(&w, int64(c.canotoData.RepeatedUint64Size))
		for _, v := range c.RepeatedUint64 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedSint8) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedSint8__tag)
		canoto.AppendInt(&w, int64(c.canotoData.RepeatedSint8Size))
		for _, v := range c.RepeatedSint8 {
			canoto.AppendSint(&w, v)
		}
	}
	if len(c.RepeatedSint16) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedSint16__tag)
		canoto.AppendInt(&w, int64(c.canotoData.RepeatedSint16Size))
		for _, v := range c.RepeatedSint16 {
			canoto.AppendSint(&w, v)
		}
	}
	if len(c.RepeatedSint32) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedSint32__tag)
		canoto.AppendInt(&w, int64(c.canotoData.RepeatedSint32Size))
		for _, v := range c.RepeatedSint32 {
			canoto.AppendSint(&w, v)
		}
	}
	if len(c.RepeatedSint64) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedSint64__tag)
		canoto.AppendInt(&w, int64(c.canotoData.RepeatedSint64Size))
		for _, v := range c.RepeatedSint64 {
			canoto.AppendSint(&w, v)
		}
	}
	if num := len(c.RepeatedFixed32); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedFixed32__tag)
		canoto.AppendInt(&w, int64(num*canoto.SizeFint32))
		for _, v := range c.RepeatedFixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if num := len(c.RepeatedFixed64); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedFixed64__tag)
		canoto.AppendInt(&w, int64(num*canoto.SizeFint64))
		for _, v := range c.RepeatedFixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if num := len(c.RepeatedSfixed32); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedSfixed32__tag)
		canoto.AppendInt(&w, int64(num*canoto.SizeFint32))
		for _, v := range c.RepeatedSfixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if num := len(c.RepeatedSfixed64); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedSfixed64__tag)
		canoto.AppendInt(&w, int64(num*canoto.SizeFint64))
		for _, v := range c.RepeatedSfixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if num := len(c.RepeatedBool); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedBool__tag)
		canoto.AppendInt(&w, int64(num*canoto.SizeBool))
		for _, v := range c.RepeatedBool {
			canoto.AppendBool(&w, v)
		}
	}
	for _, v := range c.RepeatedString {
		canoto.Append(&w, canoto__Scalars__RepeatedString__tag)
		canoto.AppendBytes(&w, v)
	}
	for _, v := range c.RepeatedBytes {
		canoto.Append(&w, canoto__Scalars__RepeatedBytes__tag)
		canoto.AppendBytes(&w, v)
	}
	for i := range c.RepeatedLargestFieldNumber {
		canoto.Append(&w, canoto__Scalars__RepeatedLargestFieldNumber__tag)
		canoto.AppendInt(&w, int64((&c.RepeatedLargestFieldNumber[i]).CachedCanotoSize()))
		w = (&c.RepeatedLargestFieldNumber[i]).MarshalCanotoInto(w)
	}
	if !canoto.IsZero(c.FixedRepeatedInt8) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt8__tag)
		canoto.AppendInt(&w, int64(c.canotoData.FixedRepeatedInt8Size))
		for _, v := range &c.FixedRepeatedInt8 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt16) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt16__tag)
		canoto.AppendInt(&w, int64(c.canotoData.FixedRepeatedInt16Size))
		for _, v := range &c.FixedRepeatedInt16 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt32) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt32__tag)
		canoto.AppendInt(&w, int64(c.canotoData.FixedRepeatedInt32Size))
		for _, v := range &c.FixedRepeatedInt32 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt64) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt64__tag)
		canoto.AppendInt(&w, int64(c.canotoData.FixedRepeatedInt64Size))
		for _, v := range &c.FixedRepeatedInt64 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint8) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint8__tag)
		canoto.AppendInt(&w, int64(c.canotoData.FixedRepeatedUint8Size))
		for _, v := range &c.FixedRepeatedUint8 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint16) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint16__tag)
		canoto.AppendInt(&w, int64(c.canotoData.FixedRepeatedUint16Size))
		for _, v := range &c.FixedRepeatedUint16 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint32) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint32__tag)
		canoto.AppendInt(&w, int64(c.canotoData.FixedRepeatedUint32Size))
		for _, v := range &c.FixedRepeatedUint32 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint64) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint64__tag)
		canoto.AppendInt(&w, int64(c.canotoData.FixedRepeatedUint64Size))
		for _, v := range &c.FixedRepeatedUint64 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedSint8) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedSint8__tag)
		canoto.AppendInt(&w, int64(c.canotoData.FixedRepeatedSint8Size))
		for _, v := range &c.FixedRepeatedSint8 {
			canoto.AppendSint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedSint16) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedSint16__tag)
		canoto.AppendInt(&w, int64(c.canotoData.FixedRepeatedSint16Size))
		for _, v := range &c.FixedRepeatedSint16 {
			canoto.AppendSint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedSint32) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedSint32__tag)
		canoto.AppendInt(&w, int64(c.canotoData.FixedRepeatedSint32Size))
		for _, v := range &c.FixedRepeatedSint32 {
			canoto.AppendSint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedSint64) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedSint64__tag)
		canoto.AppendInt(&w, int64(c.canotoData.FixedRepeatedSint64Size))
		for _, v := range &c.FixedRepeatedSint64 {
			canoto.AppendSint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixed32) {
		const fieldSize = len(c.FixedRepeatedFixed32) * canoto.SizeFint32
		canoto.Append(&w, canoto__Scalars__FixedRepeatedFixed32__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		for _, v := range &c.FixedRepeatedFixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixed64) {
		const fieldSize = len(c.FixedRepeatedFixed64) * canoto.SizeFint64
		canoto.Append(&w, canoto__Scalars__FixedRepeatedFixed64__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		for _, v := range &c.FixedRepeatedFixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed32) {
		const fieldSize = len(c.FixedRepeatedSfixed32) * canoto.SizeFint32
		canoto.Append(&w, canoto__Scalars__FixedRepeatedSfixed32__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		for _, v := range &c.FixedRepeatedSfixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed64) {
		const fieldSize = len(c.FixedRepeatedSfixed64) * canoto.SizeFint64
		canoto.Append(&w, canoto__Scalars__FixedRepeatedSfixed64__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		for _, v := range &c.FixedRepeatedSfixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedBool) {
		const fieldSize = len(c.FixedRepeatedBool) * canoto.SizeBool
		canoto.Append(&w, canoto__Scalars__FixedRepeatedBool__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		for _, v := range &c.FixedRepeatedBool {
			canoto.AppendBool(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedString) {
		for _, v := range &c.FixedRepeatedString {
			canoto.Append(&w, canoto__Scalars__FixedRepeatedString__tag)
			canoto.AppendBytes(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedBytes) {
		canoto.Append(&w, canoto__Scalars__FixedBytes__tag)
		canoto.AppendBytes(&w, (&c.FixedBytes)[:])
	}
	for i := range c.RepeatedFixedBytes {
		canoto.Append(&w, canoto__Scalars__RepeatedFixedBytes__tag)
		canoto.AppendBytes(&w, (&c.RepeatedFixedBytes[i])[:])
	}
	{
		isZero := true
		for _, v := range c.FixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.FixedRepeatedBytes {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedBytes__tag)
				canoto.AppendBytes(&w, v)
			}
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixedBytes) {
		for i := range c.FixedRepeatedFixedBytes {
			canoto.Append(&w, canoto__Scalars__FixedRepeatedFixedBytes__tag)
			canoto.AppendBytes(&w, (&(&c.FixedRepeatedFixedBytes)[i])[:])
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedLargestFieldNumber {
			if (&c.FixedRepeatedLargestFieldNumber[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedLargestFieldNumber {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedLargestFieldNumber__tag)
				canoto.AppendInt(&w, int64((&c.FixedRepeatedLargestFieldNumber[i]).CachedCanotoSize()))
				w = (&c.FixedRepeatedLargestFieldNumber[i]).MarshalCanotoInto(w)
			}
		}
	}
	if !canoto.IsZero(c.ConstRepeatedUint64) {
		canoto.Append(&w, canoto__Scalars__ConstRepeatedUint64__tag)
		canoto.AppendInt(&w, int64(c.canotoData.ConstRepeatedUint64Size))
		for _, v := range &c.ConstRepeatedUint64 {
			canoto.AppendInt(&w, v)
		}
	}
	if fieldSize := (&c.CustomType).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__CustomType__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.CustomType).MarshalCanotoInto(w)
	}
	if !canoto.IsZero(c.CustomUint32) {
		canoto.Append(&w, canoto__Scalars__CustomUint32__tag)
		canoto.AppendFint32(&w, c.CustomUint32)
	}
	if len(c.CustomString) != 0 {
		canoto.Append(&w, canoto__Scalars__CustomString__tag)
		canoto.AppendBytes(&w, c.CustomString)
	}
	if len(c.CustomBytes) != 0 {
		canoto.Append(&w, canoto__Scalars__CustomBytes__tag)
		canoto.AppendBytes(&w, c.CustomBytes)
	}
	if !canoto.IsZero(c.CustomFixedBytes) {
		canoto.Append(&w, canoto__Scalars__CustomFixedBytes__tag)
		canoto.AppendBytes(&w, (&c.CustomFixedBytes)[:])
	}
	for _, v := range c.CustomRepeatedBytes {
		canoto.Append(&w, canoto__Scalars__CustomRepeatedBytes__tag)
		canoto.AppendBytes(&w, v)
	}
	for i := range c.CustomRepeatedFixedBytes {
		canoto.Append(&w, canoto__Scalars__CustomRepeatedFixedBytes__tag)
		canoto.AppendBytes(&w, (&c.CustomRepeatedFixedBytes[i])[:])
	}
	{
		isZero := true
		for _, v := range c.CustomFixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.CustomFixedRepeatedBytes {
				canoto.Append(&w, canoto__Scalars__CustomFixedRepeatedBytes__tag)
				canoto.AppendBytes(&w, v)
			}
		}
	}
	if !canoto.IsZero(c.CustomFixedRepeatedFixedBytes) {
		for i := range c.CustomFixedRepeatedFixedBytes {
			canoto.Append(&w, canoto__Scalars__CustomFixedRepeatedFixedBytes__tag)
			canoto.AppendBytes(&w, (&(&c.CustomFixedRepeatedFixedBytes)[i])[:])
		}
	}
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__OneOf__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.OneOf).MarshalCanotoInto(w)
	}
	if c.Pointer != nil {
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Scalars__Pointer__tag)
			canoto.AppendInt(&w, int64(fieldSize))
			w = (c.Pointer).MarshalCanotoInto(w)
		}
	}
	for i := range c.RepeatedPointer {
		canoto.Append(&w, canoto__Scalars__RepeatedPointer__tag)
		var fieldSize int
		if c.RepeatedPointer[i] != nil {
			fieldSize = (c.RepeatedPointer[i]).CachedCanotoSize()
		}
		canoto.AppendInt(&w, int64(fieldSize))
		if fieldSize != 0 {
			w = (c.RepeatedPointer[i]).MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedPointer {
			if c.FixedRepeatedPointer[i] != nil && (c.FixedRepeatedPointer[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedPointer {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedPointer__tag)
				var fieldSize int
				if c.FixedRepeatedPointer[i] != nil {
					fieldSize = (c.FixedRepeatedPointer[i]).CachedCanotoSize()
				}
				canoto.AppendInt(&w, int64(fieldSize))
				if fieldSize != 0 {
					w = (c.FixedRepeatedPointer[i]).MarshalCanotoInto(w)
				}
			}
		}
	}
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__Field__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = c.Field.MarshalCanotoInto(w)
	}
	for i := range c.RepeatedField {
		canoto.Append(&w, canoto__Scalars__RepeatedField__tag)
		fieldSize := c.RepeatedField[i].CachedCanotoSize()
		canoto.AppendInt(&w, int64(fieldSize))
		if fieldSize != 0 {
			w = c.RepeatedField[i].MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedField {
			if c.FixedRepeatedField[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedField {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedField__tag)
				fieldSize := c.FixedRepeatedField[i].CachedCanotoSize()
				canoto.AppendInt(&w, int64(fieldSize))
				if fieldSize != 0 {
					w = c.FixedRepeatedField[i].MarshalCanotoInto(w)
				}
			}
		}
	}
	return w
}
