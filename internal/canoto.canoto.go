// Code generated by canoto. DO NOT EDIT.
// versions:
// 	canoto v0.16.1
// source: canoto.go

package examples

import (
	"io"
	"reflect"
	"sync/atomic"

	"github.com/StephenButtolph/canoto"
)

// Ensure that unused imports do not error
var (
	_ atomic.Uint64

	_ = io.ErrUnexpectedEOF
)

const (
	canoto__LargestFieldNumber__Uint__tag = "\xf8\xff\xff\xff\x0f" // canoto.Tag(536870911, canoto.Varint)
)

type canotoData_LargestFieldNumber struct {
	size atomic.Uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*LargestFieldNumber[T1]) CanotoSpec(...reflect.Type) *canoto.Spec {
	var zero LargestFieldNumber[T1]
	s := &canoto.Spec{
		Name: "LargestFieldNumber",
		Fields: []canoto.FieldType{
			{
				FieldNumber: 536870911,
				Name:        "Uint",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*LargestFieldNumber[T1]) MakeCanoto() *LargestFieldNumber[T1] {
	return new(LargestFieldNumber[T1])
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *LargestFieldNumber[T1]) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *LargestFieldNumber[T1]) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = LargestFieldNumber[T1]{}
	c.canotoData.size.Store(uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 536870911:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *LargestFieldNumber[T1]) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *LargestFieldNumber[T1]) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if !canoto.IsZero(c.Uint) {
		size += uint64(len(canoto__LargestFieldNumber__Uint__tag)) + canoto.SizeUint(c.Uint)
	}
	c.canotoData.size.Store(size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *LargestFieldNumber[T1]) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return c.canotoData.size.Load()
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *LargestFieldNumber[T1]) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *LargestFieldNumber[T1]) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Uint) {
		canoto.Append(&w, canoto__LargestFieldNumber__Uint__tag)
		canoto.AppendUint(&w, c.Uint)
	}
	return w
}

const (
	canoto__OneOf__A1__tag = "\x08" // canoto.Tag(1, canoto.Varint)
	canoto__OneOf__B1__tag = "\x18" // canoto.Tag(3, canoto.Varint)
	canoto__OneOf__B2__tag = "\x20" // canoto.Tag(4, canoto.Varint)
	canoto__OneOf__C__tag  = "\x28" // canoto.Tag(5, canoto.Varint)
	canoto__OneOf__D__tag  = "\x30" // canoto.Tag(6, canoto.Varint)
	canoto__OneOf__A2__tag = "\x38" // canoto.Tag(7, canoto.Varint)
)

type canotoData_OneOf struct {
	size uint64

	AOneOf uint32
	BOneOf uint32
}

// CanotoSpec returns the specification of this canoto message.
func (*OneOf) CanotoSpec(...reflect.Type) *canoto.Spec {
	var zero OneOf
	s := &canoto.Spec{
		Name: "OneOf",
		Fields: []canoto.FieldType{
			{
				FieldNumber: 1,
				Name:        "A1",
				OneOf:       "A",
				TypeInt:     canoto.SizeOf(zero.A1),
			},
			{
				FieldNumber: 3,
				Name:        "B1",
				OneOf:       "B",
				TypeInt:     canoto.SizeOf(zero.B1),
			},
			{
				FieldNumber: 4,
				Name:        "B2",
				OneOf:       "B",
				TypeInt:     canoto.SizeOf(zero.B2),
			},
			{
				FieldNumber: 5,
				Name:        "C",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.C),
			},
			{
				FieldNumber: 6,
				Name:        "D",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.D),
			},
			{
				FieldNumber: 7,
				Name:        "A2",
				OneOf:       "A",
				TypeInt:     canoto.SizeOf(zero.A2),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*OneOf) MakeCanoto() *OneOf {
	return new(OneOf)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *OneOf) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *OneOf) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = OneOf{}
	c.canotoData.size = uint64(len(r.B))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if atomic.SwapUint32(&c.canotoData.AOneOf, 1) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.A1); err != nil {
				return err
			}
			if canoto.IsZero(c.A1) {
				return canoto.ErrZeroValue
			}
		case 3:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if atomic.SwapUint32(&c.canotoData.BOneOf, 3) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.B1); err != nil {
				return err
			}
			if canoto.IsZero(c.B1) {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if atomic.SwapUint32(&c.canotoData.BOneOf, 4) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.B2); err != nil {
				return err
			}
			if canoto.IsZero(c.B2) {
				return canoto.ErrZeroValue
			}
		case 5:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.C); err != nil {
				return err
			}
			if canoto.IsZero(c.C) {
				return canoto.ErrZeroValue
			}
		case 6:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.D); err != nil {
				return err
			}
			if canoto.IsZero(c.D) {
				return canoto.ErrZeroValue
			}
		case 7:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if atomic.SwapUint32(&c.canotoData.AOneOf, 7) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.A2); err != nil {
				return err
			}
			if canoto.IsZero(c.A2) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *OneOf) ValidCanoto() bool {
	if c == nil {
		return true
	}
	var AOneOf uint32
	var BOneOf uint32
	if !canoto.IsZero(c.A1) {
		if AOneOf != 0 {
			return false
		}
		AOneOf = 1
	}
	if !canoto.IsZero(c.B1) {
		if BOneOf != 0 {
			return false
		}
		BOneOf = 3
	}
	if !canoto.IsZero(c.B2) {
		if BOneOf != 0 {
			return false
		}
		BOneOf = 4
	}
	if !canoto.IsZero(c.A2) {
		if AOneOf != 0 {
			return false
		}
		AOneOf = 7
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *OneOf) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	var AOneOf uint32
	var BOneOf uint32
	if !canoto.IsZero(c.A1) {
		size += uint64(len(canoto__OneOf__A1__tag)) + canoto.SizeInt(c.A1)
		AOneOf = 1
	}
	if !canoto.IsZero(c.B1) {
		size += uint64(len(canoto__OneOf__B1__tag)) + canoto.SizeInt(c.B1)
		BOneOf = 3
	}
	if !canoto.IsZero(c.B2) {
		size += uint64(len(canoto__OneOf__B2__tag)) + canoto.SizeInt(c.B2)
		BOneOf = 4
	}
	if !canoto.IsZero(c.C) {
		size += uint64(len(canoto__OneOf__C__tag)) + canoto.SizeInt(c.C)
	}
	if !canoto.IsZero(c.D) {
		size += uint64(len(canoto__OneOf__D__tag)) + canoto.SizeInt(c.D)
	}
	if !canoto.IsZero(c.A2) {
		size += uint64(len(canoto__OneOf__A2__tag)) + canoto.SizeInt(c.A2)
		AOneOf = 7
	}
	c.canotoData.size = size
	c.canotoData.AOneOf = AOneOf
	c.canotoData.BOneOf = BOneOf
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *OneOf) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// CachedWhichOneOfA returns the previously calculated field number used
// to represent A.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *OneOf) CachedWhichOneOfA() uint32 {
	return atomic.LoadUint32(&c.canotoData.AOneOf)
}

// CachedWhichOneOfB returns the previously calculated field number used
// to represent B.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *OneOf) CachedWhichOneOfB() uint32 {
	return atomic.LoadUint32(&c.canotoData.BOneOf)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *OneOf) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *OneOf) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.A1) {
		canoto.Append(&w, canoto__OneOf__A1__tag)
		canoto.AppendInt(&w, c.A1)
	}
	if !canoto.IsZero(c.B1) {
		canoto.Append(&w, canoto__OneOf__B1__tag)
		canoto.AppendInt(&w, c.B1)
	}
	if !canoto.IsZero(c.B2) {
		canoto.Append(&w, canoto__OneOf__B2__tag)
		canoto.AppendInt(&w, c.B2)
	}
	if !canoto.IsZero(c.C) {
		canoto.Append(&w, canoto__OneOf__C__tag)
		canoto.AppendInt(&w, c.C)
	}
	if !canoto.IsZero(c.D) {
		canoto.Append(&w, canoto__OneOf__D__tag)
		canoto.AppendInt(&w, c.D)
	}
	if !canoto.IsZero(c.A2) {
		canoto.Append(&w, canoto__OneOf__A2__tag)
		canoto.AppendInt(&w, c.A2)
	}
	return w
}

const (
	canoto__Node__Value__tag = "\x08" // canoto.Tag(1, canoto.Varint)
	canoto__Node__Next__tag  = "\x12" // canoto.Tag(2, canoto.Len)
)

type canotoData_Node struct {
	size atomic.Uint64

	OneOfOneOf atomic.Uint32
}

// CanotoSpec returns the specification of this canoto message.
func (*Node) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(Node{}))
	var zero Node
	s := &canoto.Spec{
		Name: "Node",
		Fields: []canoto.FieldType{
			{
				FieldNumber: 1,
				Name:        "Value",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.Value),
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Next),
				/*FieldNumber:   */ 2,
				/*Name:          */ "Next",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "OneOf",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*Node) MakeCanoto() *Node {
	return new(Node)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *Node) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *Node) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = Node{}
	c.canotoData.size.Store(uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Value); err != nil {
				return err
			}
			if canoto.IsZero(c.Value) {
				return canoto.ErrZeroValue
			}
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.OneOfOneOf.Swap(2) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Next = canoto.MakePointer(c.Next)
			if err := (c.Next).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Node) ValidCanoto() bool {
	if c == nil {
		return true
	}
	var OneOfOneOf uint32
	if c.Next != nil {
		(c.Next).CalculateCanotoCache()
		if (c.Next).CachedCanotoSize() != 0 {
			if OneOfOneOf != 0 {
				return false
			}
			OneOfOneOf = 2
		}
	}
	if c.Next != nil && !(c.Next).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *Node) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	var OneOfOneOf uint32
	if !canoto.IsZero(c.Value) {
		size += uint64(len(canoto__Node__Value__tag)) + canoto.SizeInt(c.Value)
	}
	if c.Next != nil {
		(c.Next).CalculateCanotoCache()
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__Node__Next__tag)) + canoto.SizeUint(fieldSize) + fieldSize
			OneOfOneOf = 2
		}
	}
	c.canotoData.size.Store(size)
	c.canotoData.OneOfOneOf.Store(OneOfOneOf)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Node) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return c.canotoData.size.Load()
}

// CachedWhichOneOfOneOf returns the previously calculated field number used
// to represent OneOf.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *Node) CachedWhichOneOfOneOf() uint32 {
	return c.canotoData.OneOfOneOf.Load()
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *Node) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *Node) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Value) {
		canoto.Append(&w, canoto__Node__Value__tag)
		canoto.AppendInt(&w, c.Value)
	}
	if c.Next != nil {
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Node__Next__tag)
			canoto.AppendUint(&w, fieldSize)
			w = (c.Next).MarshalCanotoInto(w)
		}
	}
	return w
}

const (
	canoto__RecursiveA__Next__tag = "\x0a" // canoto.Tag(1, canoto.Len)
)

type canotoData_RecursiveA struct {
	size atomic.Uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*RecursiveA) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(RecursiveA{}))
	var zero RecursiveA
	s := &canoto.Spec{
		Name: "RecursiveA",
		Fields: []canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Next),
				/*FieldNumber:   */ 1,
				/*Name:          */ "Next",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*RecursiveA) MakeCanoto() *RecursiveA {
	return new(RecursiveA)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *RecursiveA) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *RecursiveA) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = RecursiveA{}
	c.canotoData.size.Store(uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Next = canoto.MakePointer(c.Next)
			if err := (c.Next).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *RecursiveA) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if c.Next != nil && !(c.Next).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *RecursiveA) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if c.Next != nil {
		(c.Next).CalculateCanotoCache()
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__RecursiveA__Next__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	c.canotoData.size.Store(size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *RecursiveA) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return c.canotoData.size.Load()
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *RecursiveA) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *RecursiveA) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if c.Next != nil {
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__RecursiveA__Next__tag)
			canoto.AppendUint(&w, fieldSize)
			w = (c.Next).MarshalCanotoInto(w)
		}
	}
	return w
}

const (
	canoto__RecursiveB__Next__tag = "\x0a" // canoto.Tag(1, canoto.Len)
)

type canotoData_RecursiveB struct {
	size atomic.Uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*RecursiveB) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(RecursiveB{}))
	var zero RecursiveB
	s := &canoto.Spec{
		Name: "RecursiveB",
		Fields: []canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Next),
				/*FieldNumber:   */ 1,
				/*Name:          */ "Next",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*RecursiveB) MakeCanoto() *RecursiveB {
	return new(RecursiveB)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *RecursiveB) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *RecursiveB) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = RecursiveB{}
	c.canotoData.size.Store(uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Next = canoto.MakePointer(c.Next)
			if err := (c.Next).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *RecursiveB) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if c.Next != nil && !(c.Next).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *RecursiveB) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if c.Next != nil {
		(c.Next).CalculateCanotoCache()
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__RecursiveB__Next__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	c.canotoData.size.Store(size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *RecursiveB) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return c.canotoData.size.Load()
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *RecursiveB) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *RecursiveB) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if c.Next != nil {
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__RecursiveB__Next__tag)
			canoto.AppendUint(&w, fieldSize)
			w = (c.Next).MarshalCanotoInto(w)
		}
	}
	return w
}

const (
	canoto__GenericField__Value__tag                = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__GenericField__RepeatedValue__tag        = "\x12" // canoto.Tag(2, canoto.Len)
	canoto__GenericField__FixedRepeatedValue__tag   = "\x1a" // canoto.Tag(3, canoto.Len)
	canoto__GenericField__Pointer__tag              = "\x22" // canoto.Tag(4, canoto.Len)
	canoto__GenericField__RepeatedPointer__tag      = "\x2a" // canoto.Tag(5, canoto.Len)
	canoto__GenericField__FixedRepeatedPointer__tag = "\x32" // canoto.Tag(6, canoto.Len)
	canoto__GenericField__Field__tag                = "\x3a" // canoto.Tag(7, canoto.Len)
	canoto__GenericField__RepeatedField__tag        = "\x42" // canoto.Tag(8, canoto.Len)
	canoto__GenericField__FixedRepeatedField__tag   = "\x4a" // canoto.Tag(9, canoto.Len)
)

type canotoData_GenericField struct {
	size atomic.Uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*GenericField[T1, T2, T3]) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(GenericField[T1, T2, T3]{}))
	var zero GenericField[T1, T2, T3]
	s := &canoto.Spec{
		Name: "GenericField",
		Fields: []canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(&zero.Value),
				/*FieldNumber:   */ 1,
				/*Name:          */ "Value",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(canoto.MakeEntryNilPointer(zero.RepeatedValue)),
				/*FieldNumber:   */ 2,
				/*Name:          */ "RepeatedValue",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(canoto.MakeEntryNilPointer(zero.FixedRepeatedValue[:])),
				/*FieldNumber:   */ 3,
				/*Name:          */ "FixedRepeatedValue",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedValue)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(zero.Pointer),
				/*FieldNumber:   */ 4,
				/*Name:          */ "Pointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(canoto.MakeEntry(zero.RepeatedPointer)),
				/*FieldNumber:   */ 5,
				/*Name:          */ "RepeatedPointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(canoto.MakeEntry(zero.FixedRepeatedPointer[:])),
				/*FieldNumber:   */ 6,
				/*Name:          */ "FixedRepeatedPointer",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedPointer)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ zero.Field,
				/*FieldNumber:   */ 7,
				/*Name:          */ "Field",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedField),
				/*FieldNumber:   */ 8,
				/*Name:          */ "RepeatedField",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedField[:]),
				/*FieldNumber:   */ 9,
				/*Name:          */ "FixedRepeatedField",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedField)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*GenericField[T1, T2, T3]) MakeCanoto() *GenericField[T1, T2, T3] {
	return new(GenericField[T1, T2, T3])
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *GenericField[T1, T2, T3]) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *GenericField[T1, T2, T3]) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = GenericField[T1, T2, T3]{}
	c.canotoData.size.Store(uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := T2(&c.Value).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__GenericField__RepeatedValue__tag)
			if err != nil {
				return err
			}

			c.RepeatedValue = canoto.MakeSlice(c.RepeatedValue, countMinus1+1)
			field := c.RepeatedValue
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__GenericField__RepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 3:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedValue) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&c.FixedRepeatedValue[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedValue[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__GenericField__FixedRepeatedValue__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__GenericField__FixedRepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Pointer = canoto.MakePointer(c.Pointer)
			if err := T2(c.Pointer).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 5:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__GenericField__RepeatedPointer__tag)
			if err != nil {
				return err
			}

			c.RepeatedPointer = canoto.MakeSlice(c.RepeatedPointer, countMinus1+1)
			field := c.RepeatedPointer
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = canoto.MakePointer(field[0])
				if err := T2(field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__GenericField__RepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = canoto.MakePointer(additionalField[i])
				if err := T2(additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 6:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedPointer) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[0] = canoto.MakePointer(c.FixedRepeatedPointer[0])
				if err := T2(c.FixedRepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedPointer[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__GenericField__FixedRepeatedPointer__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__GenericField__FixedRepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = canoto.MakePointer(field[i])
				if err := T2(field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 7:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Field = c.Field.MakeCanoto()
			if err := c.Field.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 8:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__GenericField__RepeatedField__tag)
			if err != nil {
				return err
			}

			c.RepeatedField = canoto.MakeSlice(c.RepeatedField, countMinus1+1)
			field := c.RepeatedField
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = field[0].MakeCanoto()
				if err := field[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__GenericField__RepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = additionalField[i].MakeCanoto()
				if err := additionalField[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 9:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedField) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[0] = c.FixedRepeatedField[0].MakeCanoto()
				if err := c.FixedRepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedField[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__GenericField__FixedRepeatedField__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__GenericField__FixedRepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = field[i].MakeCanoto()
				if err := field[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *GenericField[T1, T2, T3]) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !T2(&c.Value).ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedValue
		for i := range field {
			if !T2(&field[i]).ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedValue {
		if !T2(&(&c.FixedRepeatedValue)[i]).ValidCanoto() {
			return false
		}
	}
	if c.Pointer != nil && !T2(c.Pointer).ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			if field[i] != nil && !T2(field[i]).ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedPointer {
		if (&c.FixedRepeatedPointer)[i] != nil && !T2((&c.FixedRepeatedPointer)[i]).ValidCanoto() {
			return false
		}
	}
	if !c.Field.ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedField
		for i := range field {
			if !field[i].ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedField {
		if !(&c.FixedRepeatedField)[i].ValidCanoto() {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *GenericField[T1, T2, T3]) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	T2(&c.Value).CalculateCanotoCache()
	if fieldSize := T2(&c.Value).CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__GenericField__Value__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	{
		field := c.RepeatedValue
		for i := range field {
			T2(&field[i]).CalculateCanotoCache()
			fieldSize := T2(&field[i]).CachedCanotoSize()
			size += uint64(len(canoto__GenericField__RepeatedValue__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedValue
		)
		for i := range field {
			T2(&field[i]).CalculateCanotoCache()
			fieldSize := T2(&field[i]).CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__GenericField__FixedRepeatedValue__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	if c.Pointer != nil {
		T2(c.Pointer).CalculateCanotoCache()
		if fieldSize := T2(c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__GenericField__Pointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				T2(field[i]).CalculateCanotoCache()
				fieldSize = T2(field[i]).CachedCanotoSize()
			}
			size += uint64(len(canoto__GenericField__RepeatedPointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedPointer
		)
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				T2(field[i]).CalculateCanotoCache()
				fieldSize = T2(field[i]).CachedCanotoSize()
				fieldSizeSum += fieldSize
			}
			totalSize += uint64(len(canoto__GenericField__FixedRepeatedPointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.Field.CalculateCanotoCache()
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__GenericField__Field__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	{
		field := c.RepeatedField
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			size += uint64(len(canoto__GenericField__RepeatedField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedField
		)
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__GenericField__FixedRepeatedField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.canotoData.size.Store(size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *GenericField[T1, T2, T3]) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return c.canotoData.size.Load()
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *GenericField[T1, T2, T3]) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *GenericField[T1, T2, T3]) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := T2(&c.Value).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__GenericField__Value__tag)
		canoto.AppendUint(&w, fieldSize)
		w = T2(&c.Value).MarshalCanotoInto(w)
	}
	{
		field := c.RepeatedValue
		for i := range field {
			canoto.Append(&w, canoto__GenericField__RepeatedValue__tag)
			canoto.AppendUint(&w, T2(&field[i]).CachedCanotoSize())
			w = T2(&field[i]).MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		field := &c.FixedRepeatedValue
		for i := range field {
			if T2(&field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__GenericField__FixedRepeatedValue__tag)
				canoto.AppendUint(&w, T2(&field[i]).CachedCanotoSize())
				w = T2(&field[i]).MarshalCanotoInto(w)
			}
		}
	}
	if c.Pointer != nil {
		if fieldSize := T2(c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__GenericField__Pointer__tag)
			canoto.AppendUint(&w, fieldSize)
			w = T2(c.Pointer).MarshalCanotoInto(w)
		}
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			canoto.Append(&w, canoto__GenericField__RepeatedPointer__tag)
			var fieldSize uint64
			if field[i] != nil {
				fieldSize = T2(field[i]).CachedCanotoSize()
			}
			canoto.AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = T2(field[i]).MarshalCanotoInto(w)
			}
		}
	}
	{
		isZero := true
		field := c.FixedRepeatedPointer
		for i := range field {
			if field[i] != nil && T2(field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__GenericField__FixedRepeatedPointer__tag)
				var fieldSize uint64
				if field[i] != nil {
					fieldSize = T2(field[i]).CachedCanotoSize()
				}
				canoto.AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = T2(field[i]).MarshalCanotoInto(w)
				}
			}
		}
	}
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__GenericField__Field__tag)
		canoto.AppendUint(&w, fieldSize)
		w = c.Field.MarshalCanotoInto(w)
	}
	{
		field := c.RepeatedField
		for i := range field {
			canoto.Append(&w, canoto__GenericField__RepeatedField__tag)
			fieldSize := field[i].CachedCanotoSize()
			canoto.AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = field[i].MarshalCanotoInto(w)
			}
		}
	}
	{
		isZero := true
		field := c.FixedRepeatedField
		for i := range field {
			if field[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__GenericField__FixedRepeatedField__tag)
				fieldSize := field[i].CachedCanotoSize()
				canoto.AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = field[i].MarshalCanotoInto(w)
				}
			}
		}
	}
	return w
}

const (
	canoto__NestedGenericField__Value__tag                = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__NestedGenericField__RepeatedValue__tag        = "\x12" // canoto.Tag(2, canoto.Len)
	canoto__NestedGenericField__FixedRepeatedValue__tag   = "\x1a" // canoto.Tag(3, canoto.Len)
	canoto__NestedGenericField__Pointer__tag              = "\x22" // canoto.Tag(4, canoto.Len)
	canoto__NestedGenericField__RepeatedPointer__tag      = "\x2a" // canoto.Tag(5, canoto.Len)
	canoto__NestedGenericField__FixedRepeatedPointer__tag = "\x32" // canoto.Tag(6, canoto.Len)
	canoto__NestedGenericField__Field__tag                = "\x3a" // canoto.Tag(7, canoto.Len)
	canoto__NestedGenericField__RepeatedField__tag        = "\x42" // canoto.Tag(8, canoto.Len)
	canoto__NestedGenericField__FixedRepeatedField__tag   = "\x4a" // canoto.Tag(9, canoto.Len)
)

type canotoData_NestedGenericField struct {
	size atomic.Uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*NestedGenericField[T1, T2, T3]) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(NestedGenericField[T1, T2, T3]{}))
	var zero NestedGenericField[T1, T2, T3]
	s := &canoto.Spec{
		Name: "NestedGenericField",
		Fields: []canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.Value),
				/*FieldNumber:   */ 1,
				/*Name:          */ "Value",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntryNilPointer(zero.RepeatedValue)),
				/*FieldNumber:   */ 2,
				/*Name:          */ "RepeatedValue",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntryNilPointer(zero.FixedRepeatedValue[:])),
				/*FieldNumber:   */ 3,
				/*Name:          */ "FixedRepeatedValue",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedValue)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Pointer),
				/*FieldNumber:   */ 4,
				/*Name:          */ "Pointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntry(zero.RepeatedPointer)),
				/*FieldNumber:   */ 5,
				/*Name:          */ "RepeatedPointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntry(zero.FixedRepeatedPointer[:])),
				/*FieldNumber:   */ 6,
				/*Name:          */ "FixedRepeatedPointer",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedPointer)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ zero.Field,
				/*FieldNumber:   */ 7,
				/*Name:          */ "Field",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedField),
				/*FieldNumber:   */ 8,
				/*Name:          */ "RepeatedField",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedField[:]),
				/*FieldNumber:   */ 9,
				/*Name:          */ "FixedRepeatedField",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedField)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*NestedGenericField[T1, T2, T3]) MakeCanoto() *NestedGenericField[T1, T2, T3] {
	return new(NestedGenericField[T1, T2, T3])
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *NestedGenericField[T1, T2, T3]) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *NestedGenericField[T1, T2, T3]) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = NestedGenericField[T1, T2, T3]{}
	c.canotoData.size.Store(uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.Value).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__NestedGenericField__RepeatedValue__tag)
			if err != nil {
				return err
			}

			c.RepeatedValue = canoto.MakeSlice(c.RepeatedValue, countMinus1+1)
			field := c.RepeatedValue
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__NestedGenericField__RepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 3:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedValue) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.FixedRepeatedValue[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedValue[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__NestedGenericField__FixedRepeatedValue__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__NestedGenericField__FixedRepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Pointer = canoto.MakePointer(c.Pointer)
			if err := (c.Pointer).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 5:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__NestedGenericField__RepeatedPointer__tag)
			if err != nil {
				return err
			}

			c.RepeatedPointer = canoto.MakeSlice(c.RepeatedPointer, countMinus1+1)
			field := c.RepeatedPointer
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = canoto.MakePointer(field[0])
				if err := (field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__NestedGenericField__RepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = canoto.MakePointer(additionalField[i])
				if err := (additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 6:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedPointer) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[0] = canoto.MakePointer(c.FixedRepeatedPointer[0])
				if err := (c.FixedRepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedPointer[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__NestedGenericField__FixedRepeatedPointer__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__NestedGenericField__FixedRepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = canoto.MakePointer(field[i])
				if err := (field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 7:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Field = c.Field.MakeCanoto()
			if err := c.Field.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 8:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__NestedGenericField__RepeatedField__tag)
			if err != nil {
				return err
			}

			c.RepeatedField = canoto.MakeSlice(c.RepeatedField, countMinus1+1)
			field := c.RepeatedField
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = field[0].MakeCanoto()
				if err := field[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__NestedGenericField__RepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = additionalField[i].MakeCanoto()
				if err := additionalField[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 9:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedField) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[0] = c.FixedRepeatedField[0].MakeCanoto()
				if err := c.FixedRepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedField[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__NestedGenericField__FixedRepeatedField__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__NestedGenericField__FixedRepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = field[i].MakeCanoto()
				if err := field[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *NestedGenericField[T1, T2, T3]) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.Value).ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedValue
		for i := range field {
			if !(&field[i]).ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedValue {
		if !(&(&c.FixedRepeatedValue)[i]).ValidCanoto() {
			return false
		}
	}
	if c.Pointer != nil && !(c.Pointer).ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			if field[i] != nil && !(field[i]).ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedPointer {
		if (&c.FixedRepeatedPointer)[i] != nil && !((&c.FixedRepeatedPointer)[i]).ValidCanoto() {
			return false
		}
	}
	if !c.Field.ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedField
		for i := range field {
			if !field[i].ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedField {
		if !(&c.FixedRepeatedField)[i].ValidCanoto() {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *NestedGenericField[T1, T2, T3]) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	(&c.Value).CalculateCanotoCache()
	if fieldSize := (&c.Value).CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__NestedGenericField__Value__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	{
		field := c.RepeatedValue
		for i := range field {
			(&field[i]).CalculateCanotoCache()
			fieldSize := (&field[i]).CachedCanotoSize()
			size += uint64(len(canoto__NestedGenericField__RepeatedValue__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedValue
		)
		for i := range field {
			(&field[i]).CalculateCanotoCache()
			fieldSize := (&field[i]).CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__NestedGenericField__FixedRepeatedValue__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	if c.Pointer != nil {
		(c.Pointer).CalculateCanotoCache()
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__NestedGenericField__Pointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				(field[i]).CalculateCanotoCache()
				fieldSize = (field[i]).CachedCanotoSize()
			}
			size += uint64(len(canoto__NestedGenericField__RepeatedPointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedPointer
		)
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				(field[i]).CalculateCanotoCache()
				fieldSize = (field[i]).CachedCanotoSize()
				fieldSizeSum += fieldSize
			}
			totalSize += uint64(len(canoto__NestedGenericField__FixedRepeatedPointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.Field.CalculateCanotoCache()
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__NestedGenericField__Field__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	{
		field := c.RepeatedField
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			size += uint64(len(canoto__NestedGenericField__RepeatedField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedField
		)
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__NestedGenericField__FixedRepeatedField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.canotoData.size.Store(size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *NestedGenericField[T1, T2, T3]) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return c.canotoData.size.Load()
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *NestedGenericField[T1, T2, T3]) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *NestedGenericField[T1, T2, T3]) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.Value).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__NestedGenericField__Value__tag)
		canoto.AppendUint(&w, fieldSize)
		w = (&c.Value).MarshalCanotoInto(w)
	}
	{
		field := c.RepeatedValue
		for i := range field {
			canoto.Append(&w, canoto__NestedGenericField__RepeatedValue__tag)
			canoto.AppendUint(&w, (&field[i]).CachedCanotoSize())
			w = (&field[i]).MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		field := &c.FixedRepeatedValue
		for i := range field {
			if (&field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__NestedGenericField__FixedRepeatedValue__tag)
				canoto.AppendUint(&w, (&field[i]).CachedCanotoSize())
				w = (&field[i]).MarshalCanotoInto(w)
			}
		}
	}
	if c.Pointer != nil {
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__NestedGenericField__Pointer__tag)
			canoto.AppendUint(&w, fieldSize)
			w = (c.Pointer).MarshalCanotoInto(w)
		}
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			canoto.Append(&w, canoto__NestedGenericField__RepeatedPointer__tag)
			var fieldSize uint64
			if field[i] != nil {
				fieldSize = (field[i]).CachedCanotoSize()
			}
			canoto.AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = (field[i]).MarshalCanotoInto(w)
			}
		}
	}
	{
		isZero := true
		field := c.FixedRepeatedPointer
		for i := range field {
			if field[i] != nil && (field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__NestedGenericField__FixedRepeatedPointer__tag)
				var fieldSize uint64
				if field[i] != nil {
					fieldSize = (field[i]).CachedCanotoSize()
				}
				canoto.AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = (field[i]).MarshalCanotoInto(w)
				}
			}
		}
	}
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__NestedGenericField__Field__tag)
		canoto.AppendUint(&w, fieldSize)
		w = c.Field.MarshalCanotoInto(w)
	}
	{
		field := c.RepeatedField
		for i := range field {
			canoto.Append(&w, canoto__NestedGenericField__RepeatedField__tag)
			fieldSize := field[i].CachedCanotoSize()
			canoto.AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = field[i].MarshalCanotoInto(w)
			}
		}
	}
	{
		isZero := true
		field := c.FixedRepeatedField
		for i := range field {
			if field[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__NestedGenericField__FixedRepeatedField__tag)
				fieldSize := field[i].CachedCanotoSize()
				canoto.AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = field[i].MarshalCanotoInto(w)
				}
			}
		}
	}
	return w
}

const (
	canoto__Embedded__OneOf__tag              = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__Embedded__LargestFieldNumber__tag = "\x12" // canoto.Tag(2, canoto.Len)
	canoto__Embedded__GenericField__tag       = "\x1a" // canoto.Tag(3, canoto.Len)
)

type canotoData_Embedded struct {
	size atomic.Uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*Embedded) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(Embedded{}))
	var zero Embedded
	s := &canoto.Spec{
		Name: "Embedded",
		Fields: []canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.OneOf),
				/*FieldNumber:   */ 1,
				/*Name:          */ "OneOf",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.LargestFieldNumber),
				/*FieldNumber:   */ 2,
				/*Name:          */ "LargestFieldNumber",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ zero.GenericField,
				/*FieldNumber:   */ 3,
				/*Name:          */ "GenericField",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*Embedded) MakeCanoto() *Embedded {
	return new(Embedded)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *Embedded) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *Embedded) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = Embedded{}
	c.canotoData.size.Store(uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.OneOf).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.LargestFieldNumber = canoto.MakePointer(c.LargestFieldNumber)
			if err := (c.LargestFieldNumber).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 3:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.GenericField = c.GenericField.MakeCanoto()
			if err := c.GenericField.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Embedded) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.OneOf).ValidCanoto() {
		return false
	}
	if c.LargestFieldNumber != nil && !(c.LargestFieldNumber).ValidCanoto() {
		return false
	}
	if !c.GenericField.ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *Embedded) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	(&c.OneOf).CalculateCanotoCache()
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__Embedded__OneOf__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if c.LargestFieldNumber != nil {
		(c.LargestFieldNumber).CalculateCanotoCache()
		if fieldSize := (c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__Embedded__LargestFieldNumber__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	c.GenericField.CalculateCanotoCache()
	if fieldSize := c.GenericField.CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__Embedded__GenericField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	c.canotoData.size.Store(size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Embedded) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return c.canotoData.size.Load()
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *Embedded) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *Embedded) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Embedded__OneOf__tag)
		canoto.AppendUint(&w, fieldSize)
		w = (&c.OneOf).MarshalCanotoInto(w)
	}
	if c.LargestFieldNumber != nil {
		if fieldSize := (c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Embedded__LargestFieldNumber__tag)
			canoto.AppendUint(&w, fieldSize)
			w = (c.LargestFieldNumber).MarshalCanotoInto(w)
		}
	}
	if fieldSize := c.GenericField.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Embedded__GenericField__tag)
		canoto.AppendUint(&w, fieldSize)
		w = c.GenericField.MarshalCanotoInto(w)
	}
	return w
}

const (
	canoto__A__B_1_1C__tag = "\x08" // canoto.Tag(1, canoto.Varint)
)

type canotoData_A struct {
	size atomic.Uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*A) CanotoSpec(...reflect.Type) *canoto.Spec {
	var zero A
	s := &canoto.Spec{
		Name: "A",
		Fields: []canoto.FieldType{
			{
				FieldNumber: 1,
				Name:        "B__C",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.B__C),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*A) MakeCanoto() *A {
	return new(A)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *A) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *A) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = A{}
	c.canotoData.size.Store(uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.B__C); err != nil {
				return err
			}
			if canoto.IsZero(c.B__C) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *A) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *A) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if !canoto.IsZero(c.B__C) {
		size += uint64(len(canoto__A__B_1_1C__tag)) + canoto.SizeInt(c.B__C)
	}
	c.canotoData.size.Store(size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *A) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return c.canotoData.size.Load()
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *A) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *A) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.B__C) {
		canoto.Append(&w, canoto__A__B_1_1C__tag)
		canoto.AppendInt(&w, c.B__C)
	}
	return w
}

const (
	canoto__A_1_1B__C__tag = "\x08" // canoto.Tag(1, canoto.Varint)
)

type canotoData_A__B struct {
	size atomic.Uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*A__B) CanotoSpec(...reflect.Type) *canoto.Spec {
	var zero A__B
	s := &canoto.Spec{
		Name: "A__B",
		Fields: []canoto.FieldType{
			{
				FieldNumber: 1,
				Name:        "C",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.C),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*A__B) MakeCanoto() *A__B {
	return new(A__B)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *A__B) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *A__B) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = A__B{}
	c.canotoData.size.Store(uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.C); err != nil {
				return err
			}
			if canoto.IsZero(c.C) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *A__B) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *A__B) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if !canoto.IsZero(c.C) {
		size += uint64(len(canoto__A_1_1B__C__tag)) + canoto.SizeInt(c.C)
	}
	c.canotoData.size.Store(size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *A__B) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return c.canotoData.size.Load()
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *A__B) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *A__B) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.C) {
		canoto.Append(&w, canoto__A_1_1B__C__tag)
		canoto.AppendInt(&w, c.C)
	}
	return w
}

const (
	canoto__Scalars__Int8__tag                            = "\x08"     // canoto.Tag(1, canoto.Varint)
	canoto__Scalars__Int16__tag                           = "\x10"     // canoto.Tag(2, canoto.Varint)
	canoto__Scalars__Int32__tag                           = "\x18"     // canoto.Tag(3, canoto.Varint)
	canoto__Scalars__Int64__tag                           = "\x20"     // canoto.Tag(4, canoto.Varint)
	canoto__Scalars__Uint8__tag                           = "\x28"     // canoto.Tag(5, canoto.Varint)
	canoto__Scalars__Uint16__tag                          = "\x30"     // canoto.Tag(6, canoto.Varint)
	canoto__Scalars__Uint32__tag                          = "\x38"     // canoto.Tag(7, canoto.Varint)
	canoto__Scalars__Uint64__tag                          = "\x40"     // canoto.Tag(8, canoto.Varint)
	canoto__Scalars__Sfixed32__tag                        = "\x4d"     // canoto.Tag(9, canoto.I32)
	canoto__Scalars__Fixed32__tag                         = "\x55"     // canoto.Tag(10, canoto.I32)
	canoto__Scalars__Sfixed64__tag                        = "\x59"     // canoto.Tag(11, canoto.I64)
	canoto__Scalars__Fixed64__tag                         = "\x61"     // canoto.Tag(12, canoto.I64)
	canoto__Scalars__Bool__tag                            = "\x68"     // canoto.Tag(13, canoto.Varint)
	canoto__Scalars__String__tag                          = "\x72"     // canoto.Tag(14, canoto.Len)
	canoto__Scalars__Bytes__tag                           = "\x7a"     // canoto.Tag(15, canoto.Len)
	canoto__Scalars__LargestFieldNumber__tag              = "\x82\x01" // canoto.Tag(16, canoto.Len)
	canoto__Scalars__RepeatedInt8__tag                    = "\x8a\x01" // canoto.Tag(17, canoto.Len)
	canoto__Scalars__RepeatedInt16__tag                   = "\x92\x01" // canoto.Tag(18, canoto.Len)
	canoto__Scalars__RepeatedInt32__tag                   = "\x9a\x01" // canoto.Tag(19, canoto.Len)
	canoto__Scalars__RepeatedInt64__tag                   = "\xa2\x01" // canoto.Tag(20, canoto.Len)
	canoto__Scalars__RepeatedUint8__tag                   = "\xaa\x01" // canoto.Tag(21, canoto.Len)
	canoto__Scalars__RepeatedUint16__tag                  = "\xb2\x01" // canoto.Tag(22, canoto.Len)
	canoto__Scalars__RepeatedUint32__tag                  = "\xba\x01" // canoto.Tag(23, canoto.Len)
	canoto__Scalars__RepeatedUint64__tag                  = "\xc2\x01" // canoto.Tag(24, canoto.Len)
	canoto__Scalars__RepeatedSfixed32__tag                = "\xca\x01" // canoto.Tag(25, canoto.Len)
	canoto__Scalars__RepeatedFixed32__tag                 = "\xd2\x01" // canoto.Tag(26, canoto.Len)
	canoto__Scalars__RepeatedSfixed64__tag                = "\xda\x01" // canoto.Tag(27, canoto.Len)
	canoto__Scalars__RepeatedFixed64__tag                 = "\xe2\x01" // canoto.Tag(28, canoto.Len)
	canoto__Scalars__RepeatedBool__tag                    = "\xea\x01" // canoto.Tag(29, canoto.Len)
	canoto__Scalars__RepeatedString__tag                  = "\xf2\x01" // canoto.Tag(30, canoto.Len)
	canoto__Scalars__RepeatedBytes__tag                   = "\xfa\x01" // canoto.Tag(31, canoto.Len)
	canoto__Scalars__RepeatedLargestFieldNumber__tag      = "\x82\x02" // canoto.Tag(32, canoto.Len)
	canoto__Scalars__FixedRepeatedInt8__tag               = "\x8a\x02" // canoto.Tag(33, canoto.Len)
	canoto__Scalars__FixedRepeatedInt16__tag              = "\x92\x02" // canoto.Tag(34, canoto.Len)
	canoto__Scalars__FixedRepeatedInt32__tag              = "\x9a\x02" // canoto.Tag(35, canoto.Len)
	canoto__Scalars__FixedRepeatedInt64__tag              = "\xa2\x02" // canoto.Tag(36, canoto.Len)
	canoto__Scalars__FixedRepeatedUint8__tag              = "\xaa\x02" // canoto.Tag(37, canoto.Len)
	canoto__Scalars__FixedRepeatedUint16__tag             = "\xb2\x02" // canoto.Tag(38, canoto.Len)
	canoto__Scalars__FixedRepeatedUint32__tag             = "\xba\x02" // canoto.Tag(39, canoto.Len)
	canoto__Scalars__FixedRepeatedUint64__tag             = "\xc2\x02" // canoto.Tag(40, canoto.Len)
	canoto__Scalars__FixedRepeatedSfixed32__tag           = "\xca\x02" // canoto.Tag(41, canoto.Len)
	canoto__Scalars__FixedRepeatedFixed32__tag            = "\xd2\x02" // canoto.Tag(42, canoto.Len)
	canoto__Scalars__FixedRepeatedSfixed64__tag           = "\xda\x02" // canoto.Tag(43, canoto.Len)
	canoto__Scalars__FixedRepeatedFixed64__tag            = "\xe2\x02" // canoto.Tag(44, canoto.Len)
	canoto__Scalars__FixedRepeatedBool__tag               = "\xea\x02" // canoto.Tag(45, canoto.Len)
	canoto__Scalars__FixedRepeatedString__tag             = "\xf2\x02" // canoto.Tag(46, canoto.Len)
	canoto__Scalars__FixedBytes__tag                      = "\xfa\x02" // canoto.Tag(47, canoto.Len)
	canoto__Scalars__RepeatedFixedBytes__tag              = "\x82\x03" // canoto.Tag(48, canoto.Len)
	canoto__Scalars__FixedRepeatedBytes__tag              = "\x8a\x03" // canoto.Tag(49, canoto.Len)
	canoto__Scalars__FixedRepeatedFixedBytes__tag         = "\x92\x03" // canoto.Tag(50, canoto.Len)
	canoto__Scalars__FixedRepeatedLargestFieldNumber__tag = "\x9a\x03" // canoto.Tag(51, canoto.Len)
	canoto__Scalars__ConstRepeatedUint64__tag             = "\xa2\x03" // canoto.Tag(52, canoto.Len)
	canoto__Scalars__CustomType__tag                      = "\xaa\x03" // canoto.Tag(53, canoto.Len)
	canoto__Scalars__CustomUint32__tag                    = "\xb5\x03" // canoto.Tag(54, canoto.I32)
	canoto__Scalars__CustomString__tag                    = "\xba\x03" // canoto.Tag(55, canoto.Len)
	canoto__Scalars__CustomBytes__tag                     = "\xc2\x03" // canoto.Tag(56, canoto.Len)
	canoto__Scalars__CustomFixedBytes__tag                = "\xca\x03" // canoto.Tag(57, canoto.Len)
	canoto__Scalars__CustomRepeatedBytes__tag             = "\xd2\x03" // canoto.Tag(58, canoto.Len)
	canoto__Scalars__CustomRepeatedFixedBytes__tag        = "\xda\x03" // canoto.Tag(59, canoto.Len)
	canoto__Scalars__CustomFixedRepeatedBytes__tag        = "\xe2\x03" // canoto.Tag(60, canoto.Len)
	canoto__Scalars__CustomFixedRepeatedFixedBytes__tag   = "\xea\x03" // canoto.Tag(61, canoto.Len)
	canoto__Scalars__OneOf__tag                           = "\xf2\x03" // canoto.Tag(62, canoto.Len)
	canoto__Scalars__Pointer__tag                         = "\xfa\x03" // canoto.Tag(63, canoto.Len)
	canoto__Scalars__RepeatedPointer__tag                 = "\x82\x04" // canoto.Tag(64, canoto.Len)
	canoto__Scalars__FixedRepeatedPointer__tag            = "\x8a\x04" // canoto.Tag(65, canoto.Len)
	canoto__Scalars__Field__tag                           = "\x92\x04" // canoto.Tag(66, canoto.Len)
	canoto__Scalars__RepeatedField__tag                   = "\x9a\x04" // canoto.Tag(67, canoto.Len)
	canoto__Scalars__FixedRepeatedField__tag              = "\xa2\x04" // canoto.Tag(68, canoto.Len)
)

type canotoData_Scalars struct {
	size                    uint64
	RepeatedInt8Size        uint64
	RepeatedInt16Size       uint64
	RepeatedInt32Size       uint64
	RepeatedInt64Size       uint64
	RepeatedUint8Size       uint64
	RepeatedUint16Size      uint64
	RepeatedUint32Size      uint64
	RepeatedUint64Size      uint64
	FixedRepeatedInt8Size   uint64
	FixedRepeatedInt16Size  uint64
	FixedRepeatedInt32Size  uint64
	FixedRepeatedInt64Size  uint64
	FixedRepeatedUint8Size  uint64
	FixedRepeatedUint16Size uint64
	FixedRepeatedUint32Size uint64
	FixedRepeatedUint64Size uint64
	ConstRepeatedUint64Size uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*Scalars) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(Scalars{}))
	var zero Scalars
	s := &canoto.Spec{
		Name: "Scalars",
		Fields: []canoto.FieldType{
			{
				FieldNumber: 1,
				Name:        "Int8",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.Int8),
			},
			{
				FieldNumber: 2,
				Name:        "Int16",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.Int16),
			},
			{
				FieldNumber: 3,
				Name:        "Int32",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.Int32),
			},
			{
				FieldNumber: 4,
				Name:        "Int64",
				OneOf:       "",
				TypeInt:     canoto.SizeOf(zero.Int64),
			},
			{
				FieldNumber: 5,
				Name:        "Uint8",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint8),
			},
			{
				FieldNumber: 6,
				Name:        "Uint16",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint16),
			},
			{
				FieldNumber: 7,
				Name:        "Uint32",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint32),
			},
			{
				FieldNumber: 8,
				Name:        "Uint64",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint64),
			},
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.Sfixed32,
				/*FieldNumber:   */ 9,
				/*Name:          */ "Sfixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.Fixed32,
				/*FieldNumber:   */ 10,
				/*Name:          */ "Fixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.Sfixed64,
				/*FieldNumber:   */ 11,
				/*Name:          */ "Sfixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.Fixed64,
				/*FieldNumber:   */ 12,
				/*Name:          */ "Fixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: 13,
				Name:        "Bool",
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: 14,
				Name:        "String",
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: 15,
				Name:        "Bytes",
				OneOf:       "",
				TypeBytes:   true,
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.LargestFieldNumber),
				/*FieldNumber:   */ 16,
				/*Name:          */ "LargestFieldNumber",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			{
				FieldNumber: 17,
				Name:        "RepeatedInt8",
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.RepeatedInt8)),
			},
			{
				FieldNumber: 18,
				Name:        "RepeatedInt16",
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.RepeatedInt16)),
			},
			{
				FieldNumber: 19,
				Name:        "RepeatedInt32",
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.RepeatedInt32)),
			},
			{
				FieldNumber: 20,
				Name:        "RepeatedInt64",
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.RepeatedInt64)),
			},
			{
				FieldNumber: 21,
				Name:        "RepeatedUint8",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedUint8)),
			},
			{
				FieldNumber: 22,
				Name:        "RepeatedUint16",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedUint16)),
			},
			{
				FieldNumber: 23,
				Name:        "RepeatedUint32",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedUint32)),
			},
			{
				FieldNumber: 24,
				Name:        "RepeatedUint64",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedUint64)),
			},
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedSfixed32),
				/*FieldNumber:   */ 25,
				/*Name:          */ "RepeatedSfixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedFixed32),
				/*FieldNumber:   */ 26,
				/*Name:          */ "RepeatedFixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedSfixed64),
				/*FieldNumber:   */ 27,
				/*Name:          */ "RepeatedSfixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedFixed64),
				/*FieldNumber:   */ 28,
				/*Name:          */ "RepeatedFixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: 29,
				Name:        "RepeatedBool",
				Repeated:    true,
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: 30,
				Name:        "RepeatedString",
				Repeated:    true,
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: 31,
				Name:        "RepeatedBytes",
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntryNilPointer(zero.RepeatedLargestFieldNumber)),
				/*FieldNumber:   */ 32,
				/*Name:          */ "RepeatedLargestFieldNumber",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			{
				FieldNumber: 33,
				Name:        "FixedRepeatedInt8",
				FixedLength: uint64(len(zero.FixedRepeatedInt8)),
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedInt8[:])),
			},
			{
				FieldNumber: 34,
				Name:        "FixedRepeatedInt16",
				FixedLength: uint64(len(zero.FixedRepeatedInt16)),
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedInt16[:])),
			},
			{
				FieldNumber: 35,
				Name:        "FixedRepeatedInt32",
				FixedLength: uint64(len(zero.FixedRepeatedInt32)),
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedInt32[:])),
			},
			{
				FieldNumber: 36,
				Name:        "FixedRepeatedInt64",
				FixedLength: uint64(len(zero.FixedRepeatedInt64)),
				Repeated:    true,
				OneOf:       "",
				TypeInt:     canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedInt64[:])),
			},
			{
				FieldNumber: 37,
				Name:        "FixedRepeatedUint8",
				FixedLength: uint64(len(zero.FixedRepeatedUint8)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedUint8[:])),
			},
			{
				FieldNumber: 38,
				Name:        "FixedRepeatedUint16",
				FixedLength: uint64(len(zero.FixedRepeatedUint16)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedUint16[:])),
			},
			{
				FieldNumber: 39,
				Name:        "FixedRepeatedUint32",
				FixedLength: uint64(len(zero.FixedRepeatedUint32)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedUint32[:])),
			},
			{
				FieldNumber: 40,
				Name:        "FixedRepeatedUint64",
				FixedLength: uint64(len(zero.FixedRepeatedUint64)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedUint64[:])),
			},
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedSfixed32[:]),
				/*FieldNumber:   */ 41,
				/*Name:          */ "FixedRepeatedSfixed32",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedSfixed32)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedFixed32[:]),
				/*FieldNumber:   */ 42,
				/*Name:          */ "FixedRepeatedFixed32",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedFixed32)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedSfixed64[:]),
				/*FieldNumber:   */ 43,
				/*Name:          */ "FixedRepeatedSfixed64",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedSfixed64)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedFixed64[:]),
				/*FieldNumber:   */ 44,
				/*Name:          */ "FixedRepeatedFixed64",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedFixed64)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: 45,
				Name:        "FixedRepeatedBool",
				FixedLength: uint64(len(zero.FixedRepeatedBool)),
				Repeated:    true,
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: 46,
				Name:        "FixedRepeatedString",
				FixedLength: uint64(len(zero.FixedRepeatedString)),
				Repeated:    true,
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber:    47,
				Name:           "FixedBytes",
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.FixedBytes)),
			},
			{
				FieldNumber:    48,
				Name:           "RepeatedFixedBytes",
				Repeated:       true,
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.RepeatedFixedBytes[0])),
			},
			{
				FieldNumber: 49,
				Name:        "FixedRepeatedBytes",
				FixedLength: uint64(len(zero.FixedRepeatedBytes)),
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber:    50,
				Name:           "FixedRepeatedFixedBytes",
				FixedLength:    uint64(len(zero.FixedRepeatedFixedBytes)),
				Repeated:       true,
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.FixedRepeatedFixedBytes[0])),
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntryNilPointer(zero.FixedRepeatedLargestFieldNumber[:])),
				/*FieldNumber:   */ 51,
				/*Name:          */ "FixedRepeatedLargestFieldNumber",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedLargestFieldNumber)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			{
				FieldNumber: 52,
				Name:        "ConstRepeatedUint64",
				FixedLength: uint64(len(zero.ConstRepeatedUint64)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.ConstRepeatedUint64[:])),
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.CustomType),
				/*FieldNumber:   */ 53,
				/*Name:          */ "CustomType",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.CustomUint32,
				/*FieldNumber:   */ 54,
				/*Name:          */ "CustomUint32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: 55,
				Name:        "CustomString",
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: 56,
				Name:        "CustomBytes",
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber:    57,
				Name:           "CustomFixedBytes",
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.CustomFixedBytes)),
			},
			{
				FieldNumber: 58,
				Name:        "CustomRepeatedBytes",
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber:    59,
				Name:           "CustomRepeatedFixedBytes",
				Repeated:       true,
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.CustomRepeatedFixedBytes[0])),
			},
			{
				FieldNumber: 60,
				Name:        "CustomFixedRepeatedBytes",
				FixedLength: uint64(len(zero.CustomFixedRepeatedBytes)),
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber:    61,
				Name:           "CustomFixedRepeatedFixedBytes",
				FixedLength:    uint64(len(zero.CustomFixedRepeatedFixedBytes)),
				Repeated:       true,
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.CustomFixedRepeatedFixedBytes[0])),
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.OneOf),
				/*FieldNumber:   */ 62,
				/*Name:          */ "OneOf",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Pointer),
				/*FieldNumber:   */ 63,
				/*Name:          */ "Pointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntry(zero.RepeatedPointer)),
				/*FieldNumber:   */ 64,
				/*Name:          */ "RepeatedPointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntry(zero.FixedRepeatedPointer[:])),
				/*FieldNumber:   */ 65,
				/*Name:          */ "FixedRepeatedPointer",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedPointer)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ zero.Field,
				/*FieldNumber:   */ 66,
				/*Name:          */ "Field",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedField),
				/*FieldNumber:   */ 67,
				/*Name:          */ "RepeatedField",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedField[:]),
				/*FieldNumber:   */ 68,
				/*Name:          */ "FixedRepeatedField",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedField)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*Scalars) MakeCanoto() *Scalars {
	return new(Scalars)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *Scalars) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *Scalars) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = Scalars{}
	c.canotoData.size = uint64(len(r.B))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int8); err != nil {
				return err
			}
			if canoto.IsZero(c.Int8) {
				return canoto.ErrZeroValue
			}
		case 2:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int16); err != nil {
				return err
			}
			if canoto.IsZero(c.Int16) {
				return canoto.ErrZeroValue
			}
		case 3:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int32); err != nil {
				return err
			}
			if canoto.IsZero(c.Int32) {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int64); err != nil {
				return err
			}
			if canoto.IsZero(c.Int64) {
				return canoto.ErrZeroValue
			}
		case 5:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint8); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint8) {
				return canoto.ErrZeroValue
			}
		case 6:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint16); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint16) {
				return canoto.ErrZeroValue
			}
		case 7:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint32); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint32) {
				return canoto.ErrZeroValue
			}
		case 8:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint64); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint64) {
				return canoto.ErrZeroValue
			}
		case 9:
			if wireType != canoto.I32 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint32(&r, &c.Sfixed32); err != nil {
				return err
			}
			if canoto.IsZero(c.Sfixed32) {
				return canoto.ErrZeroValue
			}
		case 10:
			if wireType != canoto.I32 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint32(&r, &c.Fixed32); err != nil {
				return err
			}
			if canoto.IsZero(c.Fixed32) {
				return canoto.ErrZeroValue
			}
		case 11:
			if wireType != canoto.I64 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint64(&r, &c.Sfixed64); err != nil {
				return err
			}
			if canoto.IsZero(c.Sfixed64) {
				return canoto.ErrZeroValue
			}
		case 12:
			if wireType != canoto.I64 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint64(&r, &c.Fixed64); err != nil {
				return err
			}
			if canoto.IsZero(c.Fixed64) {
				return canoto.ErrZeroValue
			}
		case 13:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBool(&r, &c.Bool); err != nil {
				return err
			}
			if canoto.IsZero(c.Bool) {
				return canoto.ErrZeroValue
			}
		case 14:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadString(&r, &c.String); err != nil {
				return err
			}
			if len(c.String) == 0 {
				return canoto.ErrZeroValue
			}
		case 15:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.Bytes); err != nil {
				return err
			}
			if len(c.Bytes) == 0 {
				return canoto.ErrZeroValue
			}
		case 16:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.LargestFieldNumber).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 17:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt8 = canoto.MakeSlice(c.RepeatedInt8, canoto.CountInts(msgBytes))
			field := c.RepeatedInt8
			for i := range field {
				if err := canoto.ReadInt(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedInt8Size = uint64(len(msgBytes))
		case 18:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt16 = canoto.MakeSlice(c.RepeatedInt16, canoto.CountInts(msgBytes))
			field := c.RepeatedInt16
			for i := range field {
				if err := canoto.ReadInt(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedInt16Size = uint64(len(msgBytes))
		case 19:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt32 = canoto.MakeSlice(c.RepeatedInt32, canoto.CountInts(msgBytes))
			field := c.RepeatedInt32
			for i := range field {
				if err := canoto.ReadInt(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedInt32Size = uint64(len(msgBytes))
		case 20:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt64 = canoto.MakeSlice(c.RepeatedInt64, canoto.CountInts(msgBytes))
			field := c.RepeatedInt64
			for i := range field {
				if err := canoto.ReadInt(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedInt64Size = uint64(len(msgBytes))
		case 21:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint8 = canoto.MakeSlice(c.RepeatedUint8, canoto.CountInts(msgBytes))
			field := c.RepeatedUint8
			for i := range field {
				if err := canoto.ReadUint(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedUint8Size = uint64(len(msgBytes))
		case 22:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint16 = canoto.MakeSlice(c.RepeatedUint16, canoto.CountInts(msgBytes))
			field := c.RepeatedUint16
			for i := range field {
				if err := canoto.ReadUint(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedUint16Size = uint64(len(msgBytes))
		case 23:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint32 = canoto.MakeSlice(c.RepeatedUint32, canoto.CountInts(msgBytes))
			field := c.RepeatedUint32
			for i := range field {
				if err := canoto.ReadUint(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedUint32Size = uint64(len(msgBytes))
		case 24:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint64 = canoto.MakeSlice(c.RepeatedUint64, canoto.CountInts(msgBytes))
			field := c.RepeatedUint64
			for i := range field {
				if err := canoto.ReadUint(&r, &field[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedUint64Size = uint64(len(msgBytes))
		case 25:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint32 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSfixed32 = canoto.MakeSlice(c.RepeatedSfixed32, numMsgBytes/canoto.SizeFint32)
			field := c.RepeatedSfixed32
			for i := range field {
				if err := canoto.ReadFint32(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 26:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint32 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedFixed32 = canoto.MakeSlice(c.RepeatedFixed32, numMsgBytes/canoto.SizeFint32)
			field := c.RepeatedFixed32
			for i := range field {
				if err := canoto.ReadFint32(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 27:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint64 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSfixed64 = canoto.MakeSlice(c.RepeatedSfixed64, numMsgBytes/canoto.SizeFint64)
			field := c.RepeatedSfixed64
			for i := range field {
				if err := canoto.ReadFint64(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 28:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint64 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedFixed64 = canoto.MakeSlice(c.RepeatedFixed64, numMsgBytes/canoto.SizeFint64)
			field := c.RepeatedFixed64
			for i := range field {
				if err := canoto.ReadFint64(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 29:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeBool != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedBool = canoto.MakeSlice(c.RepeatedBool, numMsgBytes/canoto.SizeBool)
			field := c.RepeatedBool
			for i := range field {
				if err := canoto.ReadBool(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 30:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedString__tag)
			if err != nil {
				return err
			}
			c.RepeatedString = canoto.MakeSlice(c.RepeatedString, countMinus1+1)
			field := c.RepeatedString

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadString(&r, &field[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__Scalars__RepeatedString__tag):]
				if err := canoto.ReadString(&r, &field[i]); err != nil {
					return err
				}
			}
		case 31:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedBytes__tag)
			if err != nil {
				return err
			}
			c.RepeatedBytes = canoto.MakeSlice(c.RepeatedBytes, countMinus1+1)
			field := c.RepeatedBytes

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadBytes(&r, &field[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__Scalars__RepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &field[i]); err != nil {
					return err
				}
			}
		case 32:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedLargestFieldNumber__tag)
			if err != nil {
				return err
			}

			c.RepeatedLargestFieldNumber = canoto.MakeSlice(c.RepeatedLargestFieldNumber, countMinus1+1)
			field := c.RepeatedLargestFieldNumber
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__Scalars__RepeatedLargestFieldNumber__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 33:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt8 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt8)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedInt8) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedInt8Size = uint64(len(msgBytes))
		case 34:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt16 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt16)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedInt16) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedInt16Size = uint64(len(msgBytes))
		case 35:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt32 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedInt32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedInt32Size = uint64(len(msgBytes))
		case 36:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt64 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedInt64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedInt64Size = uint64(len(msgBytes))
		case 37:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint8 {
				if err := canoto.ReadUint(&r, &(&c.FixedRepeatedUint8)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedUint8) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedUint8Size = uint64(len(msgBytes))
		case 38:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint16 {
				if err := canoto.ReadUint(&r, &(&c.FixedRepeatedUint16)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedUint16) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedUint16Size = uint64(len(msgBytes))
		case 39:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint32 {
				if err := canoto.ReadUint(&r, &(&c.FixedRepeatedUint32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedUint32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedUint32Size = uint64(len(msgBytes))
		case 40:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint64 {
				if err := canoto.ReadUint(&r, &(&c.FixedRepeatedUint64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedUint64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedUint64Size = uint64(len(msgBytes))
		case 41:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedSfixed32 {
				if err := canoto.ReadFint32(&r, &(&c.FixedRepeatedSfixed32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedSfixed32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 42:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedFixed32 {
				if err := canoto.ReadFint32(&r, &(&c.FixedRepeatedFixed32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedFixed32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 43:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedSfixed64 {
				if err := canoto.ReadFint64(&r, &(&c.FixedRepeatedSfixed64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedSfixed64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 44:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedFixed64 {
				if err := canoto.ReadFint64(&r, &(&c.FixedRepeatedFixed64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedFixed64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 45:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedBool {
				if err := canoto.ReadBool(&r, &(&c.FixedRepeatedBool)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedBool) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 46:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedString) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			if err := canoto.ReadString(&r, &(&c.FixedRepeatedString)[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			isZero := len((&c.FixedRepeatedString)[0]) == 0
			field := (&c.FixedRepeatedString)[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedString__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedString__tag):]
				if err := canoto.ReadString(&r, &field[i]); err != nil {
					return err
				}
				isZero = isZero && len(field[i]) == 0
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 47:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.FixedBytes)
				expectedLengthUint64 = uint64(expectedLength)
			)
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy((&c.FixedBytes)[:], r.B)
			if canoto.IsZero(c.FixedBytes) {
				return canoto.ErrZeroValue
			}
			r.B = r.B[expectedLength:]
		case 48:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.RepeatedFixedBytes[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			firstEntry := r.B[:expectedLength]
			r.B = r.B[expectedLength:]

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedFixedBytes__tag)
			if err != nil {
				return err
			}

			c.RepeatedFixedBytes = canoto.MakeSlice(c.RepeatedFixedBytes, countMinus1+1)
			field := c.RepeatedFixedBytes
			copy((&field[0])[:], firstEntry)

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__Scalars__RepeatedFixedBytes__tag):]
				if err := canoto.ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				newB := r.B[expectedLength:]
				copy(field[i][:], r.B)
				r.B = newB
			}
		case 49:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedBytes) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			if err := canoto.ReadBytes(&r, &(&c.FixedRepeatedBytes)[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			isZero := len((&c.FixedRepeatedBytes)[0]) == 0
			field := (&c.FixedRepeatedBytes)[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &field[i]); err != nil {
					return err
				}
				isZero = isZero && len(field[i]) == 0
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 50:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				// Ensure this field has a constant length of at least one.
				_                    = uint(len(c.FixedRepeatedFixedBytes) - 1)
				expectedLength       = len(c.FixedRepeatedFixedBytes[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			newB := r.B[expectedLength:]
			copy((&(&c.FixedRepeatedFixedBytes)[0])[:], r.B)
			r.B = newB

			// Read the rest of the entries, stripping the tag each time.
			field := (&c.FixedRepeatedFixedBytes)[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedFixedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedFixedBytes__tag):]

				if err := canoto.ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				newB := r.B[expectedLength:]
				copy((&field[i])[:], r.B)
				r.B = newB
			}
			if canoto.IsZero(c.FixedRepeatedFixedBytes) {
				return canoto.ErrZeroValue
			}
		case 51:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedLargestFieldNumber) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.FixedRepeatedLargestFieldNumber[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedLargestFieldNumber[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedLargestFieldNumber__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedLargestFieldNumber__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 52:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.ConstRepeatedUint64 {
				if err := canoto.ReadUint(&r, &(&c.ConstRepeatedUint64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.ConstRepeatedUint64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.ConstRepeatedUint64Size = uint64(len(msgBytes))
		case 53:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.CustomType).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 54:
			if wireType != canoto.I32 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint32(&r, &c.CustomUint32); err != nil {
				return err
			}
			if canoto.IsZero(c.CustomUint32) {
				return canoto.ErrZeroValue
			}
		case 55:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadString(&r, &c.CustomString); err != nil {
				return err
			}
			if len(c.CustomString) == 0 {
				return canoto.ErrZeroValue
			}
		case 56:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.CustomBytes); err != nil {
				return err
			}
			if len(c.CustomBytes) == 0 {
				return canoto.ErrZeroValue
			}
		case 57:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.CustomFixedBytes)
				expectedLengthUint64 = uint64(expectedLength)
			)
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy((&c.CustomFixedBytes)[:], r.B)
			if canoto.IsZero(c.CustomFixedBytes) {
				return canoto.ErrZeroValue
			}
			r.B = r.B[expectedLength:]
		case 58:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__CustomRepeatedBytes__tag)
			if err != nil {
				return err
			}
			c.CustomRepeatedBytes = canoto.MakeSlice(c.CustomRepeatedBytes, countMinus1+1)
			field := c.CustomRepeatedBytes

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadBytes(&r, &field[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__Scalars__CustomRepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &field[i]); err != nil {
					return err
				}
			}
		case 59:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.CustomRepeatedFixedBytes[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			firstEntry := r.B[:expectedLength]
			r.B = r.B[expectedLength:]

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__CustomRepeatedFixedBytes__tag)
			if err != nil {
				return err
			}

			c.CustomRepeatedFixedBytes = canoto.MakeSlice(c.CustomRepeatedFixedBytes, countMinus1+1)
			field := c.CustomRepeatedFixedBytes
			copy((&field[0])[:], firstEntry)

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__Scalars__CustomRepeatedFixedBytes__tag):]
				if err := canoto.ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				newB := r.B[expectedLength:]
				copy(field[i][:], r.B)
				r.B = newB
			}
		case 60:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.CustomFixedRepeatedBytes) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			if err := canoto.ReadBytes(&r, &(&c.CustomFixedRepeatedBytes)[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			isZero := len((&c.CustomFixedRepeatedBytes)[0]) == 0
			field := (&c.CustomFixedRepeatedBytes)[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__CustomFixedRepeatedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__CustomFixedRepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &field[i]); err != nil {
					return err
				}
				isZero = isZero && len(field[i]) == 0
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 61:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				// Ensure this field has a constant length of at least one.
				_                    = uint(len(c.CustomFixedRepeatedFixedBytes) - 1)
				expectedLength       = len(c.CustomFixedRepeatedFixedBytes[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			newB := r.B[expectedLength:]
			copy((&(&c.CustomFixedRepeatedFixedBytes)[0])[:], r.B)
			r.B = newB

			// Read the rest of the entries, stripping the tag each time.
			field := (&c.CustomFixedRepeatedFixedBytes)[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__CustomFixedRepeatedFixedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__CustomFixedRepeatedFixedBytes__tag):]

				if err := canoto.ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				newB := r.B[expectedLength:]
				copy((&field[i])[:], r.B)
				r.B = newB
			}
			if canoto.IsZero(c.CustomFixedRepeatedFixedBytes) {
				return canoto.ErrZeroValue
			}
		case 62:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.OneOf).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 63:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Pointer = canoto.MakePointer(c.Pointer)
			if err := (c.Pointer).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 64:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedPointer__tag)
			if err != nil {
				return err
			}

			c.RepeatedPointer = canoto.MakeSlice(c.RepeatedPointer, countMinus1+1)
			field := c.RepeatedPointer
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = canoto.MakePointer(field[0])
				if err := (field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__Scalars__RepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = canoto.MakePointer(additionalField[i])
				if err := (additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 65:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedPointer) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[0] = canoto.MakePointer(c.FixedRepeatedPointer[0])
				if err := (c.FixedRepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedPointer[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedPointer__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = canoto.MakePointer(field[i])
				if err := (field[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 66:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Field = c.Field.MakeCanoto()
			if err := c.Field.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 67:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedField__tag)
			if err != nil {
				return err
			}

			c.RepeatedField = canoto.MakeSlice(c.RepeatedField, countMinus1+1)
			field := c.RepeatedField
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				field[0] = field[0].MakeCanoto()
				if err := field[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__Scalars__RepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				additionalField[i] = additionalField[i].MakeCanoto()
				if err := additionalField[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 68:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Ensure this field has a constant length of at least one.
			const _ = uint(len(c.FixedRepeatedField) - 1)

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[0] = c.FixedRepeatedField[0].MakeCanoto()
				if err := c.FixedRepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			field := c.FixedRepeatedField[1:]
			for i := range field {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedField__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				field[i] = field[i].MakeCanoto()
				if err := field[i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Scalars) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !canoto.ValidString(c.String) {
		return false
	}
	if !(&c.LargestFieldNumber).ValidCanoto() {
		return false
	}
	for _, v := range c.RepeatedString {
		if !canoto.ValidString(v) {
			return false
		}
	}
	{
		field := c.RepeatedLargestFieldNumber
		for i := range field {
			if !(&field[i]).ValidCanoto() {
				return false
			}
		}
	}
	for _, v := range &c.FixedRepeatedString {
		if !canoto.ValidString(v) {
			return false
		}
	}
	for i := range &c.FixedRepeatedLargestFieldNumber {
		if !(&(&c.FixedRepeatedLargestFieldNumber)[i]).ValidCanoto() {
			return false
		}
	}
	if !(&c.CustomType).ValidCanoto() {
		return false
	}
	if !canoto.ValidString(c.CustomString) {
		return false
	}
	if !(&c.OneOf).ValidCanoto() {
		return false
	}
	if c.Pointer != nil && !(c.Pointer).ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			if field[i] != nil && !(field[i]).ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedPointer {
		if (&c.FixedRepeatedPointer)[i] != nil && !((&c.FixedRepeatedPointer)[i]).ValidCanoto() {
			return false
		}
	}
	if !c.Field.ValidCanoto() {
		return false
	}
	{
		field := c.RepeatedField
		for i := range field {
			if !field[i].ValidCanoto() {
				return false
			}
		}
	}
	for i := range &c.FixedRepeatedField {
		if !(&c.FixedRepeatedField)[i].ValidCanoto() {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *Scalars) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if !canoto.IsZero(c.Int8) {
		size += uint64(len(canoto__Scalars__Int8__tag)) + canoto.SizeInt(c.Int8)
	}
	if !canoto.IsZero(c.Int16) {
		size += uint64(len(canoto__Scalars__Int16__tag)) + canoto.SizeInt(c.Int16)
	}
	if !canoto.IsZero(c.Int32) {
		size += uint64(len(canoto__Scalars__Int32__tag)) + canoto.SizeInt(c.Int32)
	}
	if !canoto.IsZero(c.Int64) {
		size += uint64(len(canoto__Scalars__Int64__tag)) + canoto.SizeInt(c.Int64)
	}
	if !canoto.IsZero(c.Uint8) {
		size += uint64(len(canoto__Scalars__Uint8__tag)) + canoto.SizeUint(c.Uint8)
	}
	if !canoto.IsZero(c.Uint16) {
		size += uint64(len(canoto__Scalars__Uint16__tag)) + canoto.SizeUint(c.Uint16)
	}
	if !canoto.IsZero(c.Uint32) {
		size += uint64(len(canoto__Scalars__Uint32__tag)) + canoto.SizeUint(c.Uint32)
	}
	if !canoto.IsZero(c.Uint64) {
		size += uint64(len(canoto__Scalars__Uint64__tag)) + canoto.SizeUint(c.Uint64)
	}
	if !canoto.IsZero(c.Sfixed32) {
		size += uint64(len(canoto__Scalars__Sfixed32__tag)) + canoto.SizeFint32
	}
	if !canoto.IsZero(c.Fixed32) {
		size += uint64(len(canoto__Scalars__Fixed32__tag)) + canoto.SizeFint32
	}
	if !canoto.IsZero(c.Sfixed64) {
		size += uint64(len(canoto__Scalars__Sfixed64__tag)) + canoto.SizeFint64
	}
	if !canoto.IsZero(c.Fixed64) {
		size += uint64(len(canoto__Scalars__Fixed64__tag)) + canoto.SizeFint64
	}
	if !canoto.IsZero(c.Bool) {
		size += uint64(len(canoto__Scalars__Bool__tag)) + canoto.SizeBool
	}
	if len(c.String) != 0 {
		size += uint64(len(canoto__Scalars__String__tag)) + canoto.SizeBytes(c.String)
	}
	if len(c.Bytes) != 0 {
		size += uint64(len(canoto__Scalars__Bytes__tag)) + canoto.SizeBytes(c.Bytes)
	}
	(&c.LargestFieldNumber).CalculateCanotoCache()
	if fieldSize := (&c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__Scalars__LargestFieldNumber__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if len(c.RepeatedInt8) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedInt8 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedInt8__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.RepeatedInt8Size = fieldSize
	}
	if len(c.RepeatedInt16) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedInt16 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedInt16__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.RepeatedInt16Size = fieldSize
	}
	if len(c.RepeatedInt32) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedInt32 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedInt32__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.RepeatedInt32Size = fieldSize
	}
	if len(c.RepeatedInt64) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedInt64 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedInt64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.RepeatedInt64Size = fieldSize
	}
	if len(c.RepeatedUint8) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedUint8 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedUint8__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.RepeatedUint8Size = fieldSize
	}
	if len(c.RepeatedUint16) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedUint16 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedUint16__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.RepeatedUint16Size = fieldSize
	}
	if len(c.RepeatedUint32) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedUint32 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedUint32__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.RepeatedUint32Size = fieldSize
	}
	if len(c.RepeatedUint64) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedUint64 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__RepeatedUint64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.RepeatedUint64Size = fieldSize
	}
	if num := uint64(len(c.RepeatedSfixed32)); num != 0 {
		fieldSize := num * canoto.SizeFint32
		size += uint64(len(canoto__Scalars__RepeatedSfixed32__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if num := uint64(len(c.RepeatedFixed32)); num != 0 {
		fieldSize := num * canoto.SizeFint32
		size += uint64(len(canoto__Scalars__RepeatedFixed32__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if num := uint64(len(c.RepeatedSfixed64)); num != 0 {
		fieldSize := num * canoto.SizeFint64
		size += uint64(len(canoto__Scalars__RepeatedSfixed64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if num := uint64(len(c.RepeatedFixed64)); num != 0 {
		fieldSize := num * canoto.SizeFint64
		size += uint64(len(canoto__Scalars__RepeatedFixed64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if num := uint64(len(c.RepeatedBool)); num != 0 {
		fieldSize := num * canoto.SizeBool
		size += uint64(len(canoto__Scalars__RepeatedBool__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	for _, v := range c.RepeatedString {
		size += uint64(len(canoto__Scalars__RepeatedString__tag)) + canoto.SizeBytes(v)
	}
	for _, v := range c.RepeatedBytes {
		size += uint64(len(canoto__Scalars__RepeatedBytes__tag)) + canoto.SizeBytes(v)
	}
	{
		field := c.RepeatedLargestFieldNumber
		for i := range field {
			(&field[i]).CalculateCanotoCache()
			fieldSize := (&field[i]).CachedCanotoSize()
			size += uint64(len(canoto__Scalars__RepeatedLargestFieldNumber__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt8) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedInt8 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedInt8__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.FixedRepeatedInt8Size = fieldSize
	}
	if !canoto.IsZero(c.FixedRepeatedInt16) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedInt16 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedInt16__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.FixedRepeatedInt16Size = fieldSize
	}
	if !canoto.IsZero(c.FixedRepeatedInt32) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedInt32 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedInt32__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.FixedRepeatedInt32Size = fieldSize
	}
	if !canoto.IsZero(c.FixedRepeatedInt64) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedInt64 {
			fieldSize += canoto.SizeInt(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedInt64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.FixedRepeatedInt64Size = fieldSize
	}
	if !canoto.IsZero(c.FixedRepeatedUint8) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedUint8 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedUint8__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.FixedRepeatedUint8Size = fieldSize
	}
	if !canoto.IsZero(c.FixedRepeatedUint16) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedUint16 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedUint16__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.FixedRepeatedUint16Size = fieldSize
	}
	if !canoto.IsZero(c.FixedRepeatedUint32) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedUint32 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedUint32__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.FixedRepeatedUint32Size = fieldSize
	}
	if !canoto.IsZero(c.FixedRepeatedUint64) {
		var fieldSize uint64
		for _, v := range &c.FixedRepeatedUint64 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__FixedRepeatedUint64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.FixedRepeatedUint64Size = fieldSize
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed32) {
		const fieldSize = uint64(len(c.FixedRepeatedSfixed32)) * canoto.SizeFint32
		size += uint64(len(canoto__Scalars__FixedRepeatedSfixed32__tag)) + fieldSize + canoto.SizeUint(fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedFixed32) {
		const fieldSize = uint64(len(c.FixedRepeatedFixed32)) * canoto.SizeFint32
		size += uint64(len(canoto__Scalars__FixedRepeatedFixed32__tag)) + fieldSize + canoto.SizeUint(fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed64) {
		const fieldSize = uint64(len(c.FixedRepeatedSfixed64)) * canoto.SizeFint64
		size += uint64(len(canoto__Scalars__FixedRepeatedSfixed64__tag)) + fieldSize + canoto.SizeUint(fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedFixed64) {
		const fieldSize = uint64(len(c.FixedRepeatedFixed64)) * canoto.SizeFint64
		size += uint64(len(canoto__Scalars__FixedRepeatedFixed64__tag)) + fieldSize + canoto.SizeUint(fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedBool) {
		const fieldSize = uint64(len(c.FixedRepeatedBool)) * canoto.SizeBool
		size += uint64(len(canoto__Scalars__FixedRepeatedBool__tag)) + fieldSize + canoto.SizeUint(fieldSize)
	}
	if !canoto.IsZero(c.FixedRepeatedString) {
		for _, v := range &c.FixedRepeatedString {
			size += uint64(len(canoto__Scalars__FixedRepeatedString__tag)) + canoto.SizeBytes(v)
		}
	}
	if !canoto.IsZero(c.FixedBytes) {
		size += uint64(len(canoto__Scalars__FixedBytes__tag)) + canoto.SizeBytes((&c.FixedBytes)[:])
	}
	if num := uint64(len(c.RepeatedFixedBytes)); num != 0 {
		fieldSize := uint64(len(canoto__Scalars__RepeatedFixedBytes__tag)) + canoto.SizeBytes((&c.RepeatedFixedBytes[0])[:])
		size += num * fieldSize
	}
	{
		isZero := true
		for _, v := range c.FixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.FixedRepeatedBytes {
				size += uint64(len(canoto__Scalars__FixedRepeatedBytes__tag)) + canoto.SizeBytes(v)
			}
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixedBytes) {
		for i := range c.FixedRepeatedFixedBytes {
			size += uint64(len(canoto__Scalars__FixedRepeatedFixedBytes__tag)) + canoto.SizeBytes((&(&c.FixedRepeatedFixedBytes)[i])[:])
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedLargestFieldNumber
		)
		for i := range field {
			(&field[i]).CalculateCanotoCache()
			fieldSize := (&field[i]).CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__Scalars__FixedRepeatedLargestFieldNumber__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	if !canoto.IsZero(c.ConstRepeatedUint64) {
		var fieldSize uint64
		for _, v := range &c.ConstRepeatedUint64 {
			fieldSize += canoto.SizeUint(v)
		}
		size += uint64(len(canoto__Scalars__ConstRepeatedUint64__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		c.canotoData.ConstRepeatedUint64Size = fieldSize
	}
	(&c.CustomType).CalculateCanotoCache()
	if fieldSize := (&c.CustomType).CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__Scalars__CustomType__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if !canoto.IsZero(c.CustomUint32) {
		size += uint64(len(canoto__Scalars__CustomUint32__tag)) + canoto.SizeFint32
	}
	if len(c.CustomString) != 0 {
		size += uint64(len(canoto__Scalars__CustomString__tag)) + canoto.SizeBytes(c.CustomString)
	}
	if len(c.CustomBytes) != 0 {
		size += uint64(len(canoto__Scalars__CustomBytes__tag)) + canoto.SizeBytes(c.CustomBytes)
	}
	if !canoto.IsZero(c.CustomFixedBytes) {
		size += uint64(len(canoto__Scalars__CustomFixedBytes__tag)) + canoto.SizeBytes((&c.CustomFixedBytes)[:])
	}
	for _, v := range c.CustomRepeatedBytes {
		size += uint64(len(canoto__Scalars__CustomRepeatedBytes__tag)) + canoto.SizeBytes(v)
	}
	if num := uint64(len(c.CustomRepeatedFixedBytes)); num != 0 {
		fieldSize := uint64(len(canoto__Scalars__CustomRepeatedFixedBytes__tag)) + canoto.SizeBytes((&c.CustomRepeatedFixedBytes[0])[:])
		size += num * fieldSize
	}
	{
		isZero := true
		for _, v := range c.CustomFixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.CustomFixedRepeatedBytes {
				size += uint64(len(canoto__Scalars__CustomFixedRepeatedBytes__tag)) + canoto.SizeBytes(v)
			}
		}
	}
	if !canoto.IsZero(c.CustomFixedRepeatedFixedBytes) {
		for i := range c.CustomFixedRepeatedFixedBytes {
			size += uint64(len(canoto__Scalars__CustomFixedRepeatedFixedBytes__tag)) + canoto.SizeBytes((&(&c.CustomFixedRepeatedFixedBytes)[i])[:])
		}
	}
	(&c.OneOf).CalculateCanotoCache()
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__Scalars__OneOf__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if c.Pointer != nil {
		(c.Pointer).CalculateCanotoCache()
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__Scalars__Pointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				(field[i]).CalculateCanotoCache()
				fieldSize = (field[i]).CachedCanotoSize()
			}
			size += uint64(len(canoto__Scalars__RepeatedPointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedPointer
		)
		for i := range field {
			var fieldSize uint64
			if field[i] != nil {
				(field[i]).CalculateCanotoCache()
				fieldSize = (field[i]).CachedCanotoSize()
				fieldSizeSum += fieldSize
			}
			totalSize += uint64(len(canoto__Scalars__FixedRepeatedPointer__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.Field.CalculateCanotoCache()
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__Scalars__Field__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	{
		field := c.RepeatedField
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			size += uint64(len(canoto__Scalars__RepeatedField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
	}
	{
		var (
			fieldSizeSum uint64
			totalSize    uint64
			field        = &c.FixedRepeatedField
		)
		for i := range field {
			field[i].CalculateCanotoCache()
			fieldSize := field[i].CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += uint64(len(canoto__Scalars__FixedRepeatedField__tag)) + canoto.SizeUint(fieldSize) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.canotoData.size = size
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Scalars) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Scalars) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Scalars) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Int8) {
		canoto.Append(&w, canoto__Scalars__Int8__tag)
		canoto.AppendInt(&w, c.Int8)
	}
	if !canoto.IsZero(c.Int16) {
		canoto.Append(&w, canoto__Scalars__Int16__tag)
		canoto.AppendInt(&w, c.Int16)
	}
	if !canoto.IsZero(c.Int32) {
		canoto.Append(&w, canoto__Scalars__Int32__tag)
		canoto.AppendInt(&w, c.Int32)
	}
	if !canoto.IsZero(c.Int64) {
		canoto.Append(&w, canoto__Scalars__Int64__tag)
		canoto.AppendInt(&w, c.Int64)
	}
	if !canoto.IsZero(c.Uint8) {
		canoto.Append(&w, canoto__Scalars__Uint8__tag)
		canoto.AppendUint(&w, c.Uint8)
	}
	if !canoto.IsZero(c.Uint16) {
		canoto.Append(&w, canoto__Scalars__Uint16__tag)
		canoto.AppendUint(&w, c.Uint16)
	}
	if !canoto.IsZero(c.Uint32) {
		canoto.Append(&w, canoto__Scalars__Uint32__tag)
		canoto.AppendUint(&w, c.Uint32)
	}
	if !canoto.IsZero(c.Uint64) {
		canoto.Append(&w, canoto__Scalars__Uint64__tag)
		canoto.AppendUint(&w, c.Uint64)
	}
	if !canoto.IsZero(c.Sfixed32) {
		canoto.Append(&w, canoto__Scalars__Sfixed32__tag)
		canoto.AppendFint32(&w, c.Sfixed32)
	}
	if !canoto.IsZero(c.Fixed32) {
		canoto.Append(&w, canoto__Scalars__Fixed32__tag)
		canoto.AppendFint32(&w, c.Fixed32)
	}
	if !canoto.IsZero(c.Sfixed64) {
		canoto.Append(&w, canoto__Scalars__Sfixed64__tag)
		canoto.AppendFint64(&w, c.Sfixed64)
	}
	if !canoto.IsZero(c.Fixed64) {
		canoto.Append(&w, canoto__Scalars__Fixed64__tag)
		canoto.AppendFint64(&w, c.Fixed64)
	}
	if !canoto.IsZero(c.Bool) {
		canoto.Append(&w, canoto__Scalars__Bool__tag)
		canoto.AppendBool(&w, true)
	}
	if len(c.String) != 0 {
		canoto.Append(&w, canoto__Scalars__String__tag)
		canoto.AppendBytes(&w, c.String)
	}
	if len(c.Bytes) != 0 {
		canoto.Append(&w, canoto__Scalars__Bytes__tag)
		canoto.AppendBytes(&w, c.Bytes)
	}
	if fieldSize := (&c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__LargestFieldNumber__tag)
		canoto.AppendUint(&w, fieldSize)
		w = (&c.LargestFieldNumber).MarshalCanotoInto(w)
	}
	if len(c.RepeatedInt8) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt8__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedInt8Size))
		for _, v := range c.RepeatedInt8 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt16) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt16__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedInt16Size))
		for _, v := range c.RepeatedInt16 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt32) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt32__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedInt32Size))
		for _, v := range c.RepeatedInt32 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt64) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt64__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedInt64Size))
		for _, v := range c.RepeatedInt64 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedUint8) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint8__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedUint8Size))
		for _, v := range c.RepeatedUint8 {
			canoto.AppendUint(&w, v)
		}
	}
	if len(c.RepeatedUint16) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint16__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedUint16Size))
		for _, v := range c.RepeatedUint16 {
			canoto.AppendUint(&w, v)
		}
	}
	if len(c.RepeatedUint32) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint32__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedUint32Size))
		for _, v := range c.RepeatedUint32 {
			canoto.AppendUint(&w, v)
		}
	}
	if len(c.RepeatedUint64) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint64__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedUint64Size))
		for _, v := range c.RepeatedUint64 {
			canoto.AppendUint(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedSfixed32)); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedSfixed32__tag)
		canoto.AppendUint(&w, num*canoto.SizeFint32)
		for _, v := range c.RepeatedSfixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedFixed32)); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedFixed32__tag)
		canoto.AppendUint(&w, num*canoto.SizeFint32)
		for _, v := range c.RepeatedFixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedSfixed64)); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedSfixed64__tag)
		canoto.AppendUint(&w, num*canoto.SizeFint64)
		for _, v := range c.RepeatedSfixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedFixed64)); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedFixed64__tag)
		canoto.AppendUint(&w, num*canoto.SizeFint64)
		for _, v := range c.RepeatedFixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedBool)); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedBool__tag)
		canoto.AppendUint(&w, num*canoto.SizeBool)
		for _, v := range c.RepeatedBool {
			canoto.AppendBool(&w, v)
		}
	}
	for _, v := range c.RepeatedString {
		canoto.Append(&w, canoto__Scalars__RepeatedString__tag)
		canoto.AppendBytes(&w, v)
	}
	for _, v := range c.RepeatedBytes {
		canoto.Append(&w, canoto__Scalars__RepeatedBytes__tag)
		canoto.AppendBytes(&w, v)
	}
	{
		field := c.RepeatedLargestFieldNumber
		for i := range field {
			canoto.Append(&w, canoto__Scalars__RepeatedLargestFieldNumber__tag)
			canoto.AppendUint(&w, (&field[i]).CachedCanotoSize())
			w = (&field[i]).MarshalCanotoInto(w)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt8) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt8__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedInt8Size))
		for _, v := range &c.FixedRepeatedInt8 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt16) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt16__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedInt16Size))
		for _, v := range &c.FixedRepeatedInt16 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt32) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt32__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedInt32Size))
		for _, v := range &c.FixedRepeatedInt32 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt64) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt64__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedInt64Size))
		for _, v := range &c.FixedRepeatedInt64 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint8) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint8__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedUint8Size))
		for _, v := range &c.FixedRepeatedUint8 {
			canoto.AppendUint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint16) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint16__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedUint16Size))
		for _, v := range &c.FixedRepeatedUint16 {
			canoto.AppendUint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint32) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint32__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedUint32Size))
		for _, v := range &c.FixedRepeatedUint32 {
			canoto.AppendUint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint64) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint64__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.FixedRepeatedUint64Size))
		for _, v := range &c.FixedRepeatedUint64 {
			canoto.AppendUint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed32) {
		const fieldSize = uint64(len(c.FixedRepeatedSfixed32)) * canoto.SizeFint32
		canoto.Append(&w, canoto__Scalars__FixedRepeatedSfixed32__tag)
		canoto.AppendUint(&w, fieldSize)
		for _, v := range &c.FixedRepeatedSfixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixed32) {
		const fieldSize = uint64(len(c.FixedRepeatedFixed32)) * canoto.SizeFint32
		canoto.Append(&w, canoto__Scalars__FixedRepeatedFixed32__tag)
		canoto.AppendUint(&w, fieldSize)
		for _, v := range &c.FixedRepeatedFixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed64) {
		const fieldSize = uint64(len(c.FixedRepeatedSfixed64)) * canoto.SizeFint64
		canoto.Append(&w, canoto__Scalars__FixedRepeatedSfixed64__tag)
		canoto.AppendUint(&w, fieldSize)
		for _, v := range &c.FixedRepeatedSfixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixed64) {
		const fieldSize = uint64(len(c.FixedRepeatedFixed64)) * canoto.SizeFint64
		canoto.Append(&w, canoto__Scalars__FixedRepeatedFixed64__tag)
		canoto.AppendUint(&w, fieldSize)
		for _, v := range &c.FixedRepeatedFixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedBool) {
		const fieldSize = uint64(len(c.FixedRepeatedBool)) * canoto.SizeBool
		canoto.Append(&w, canoto__Scalars__FixedRepeatedBool__tag)
		canoto.AppendUint(&w, fieldSize)
		for _, v := range &c.FixedRepeatedBool {
			canoto.AppendBool(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedString) {
		for _, v := range &c.FixedRepeatedString {
			canoto.Append(&w, canoto__Scalars__FixedRepeatedString__tag)
			canoto.AppendBytes(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedBytes) {
		canoto.Append(&w, canoto__Scalars__FixedBytes__tag)
		canoto.AppendBytes(&w, (&c.FixedBytes)[:])
	}
	{
		field := c.RepeatedFixedBytes
		for i := range field {
			canoto.Append(&w, canoto__Scalars__RepeatedFixedBytes__tag)
			canoto.AppendBytes(&w, (&field[i])[:])
		}
	}
	{
		isZero := true
		for _, v := range c.FixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.FixedRepeatedBytes {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedBytes__tag)
				canoto.AppendBytes(&w, v)
			}
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixedBytes) {
		for i := range c.FixedRepeatedFixedBytes {
			canoto.Append(&w, canoto__Scalars__FixedRepeatedFixedBytes__tag)
			canoto.AppendBytes(&w, (&(&c.FixedRepeatedFixedBytes)[i])[:])
		}
	}
	{
		isZero := true
		field := &c.FixedRepeatedLargestFieldNumber
		for i := range field {
			if (&field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedLargestFieldNumber__tag)
				canoto.AppendUint(&w, (&field[i]).CachedCanotoSize())
				w = (&field[i]).MarshalCanotoInto(w)
			}
		}
	}
	if !canoto.IsZero(c.ConstRepeatedUint64) {
		canoto.Append(&w, canoto__Scalars__ConstRepeatedUint64__tag)
		canoto.AppendUint(&w, atomic.LoadUint64(&c.canotoData.ConstRepeatedUint64Size))
		for _, v := range &c.ConstRepeatedUint64 {
			canoto.AppendUint(&w, v)
		}
	}
	if fieldSize := (&c.CustomType).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__CustomType__tag)
		canoto.AppendUint(&w, fieldSize)
		w = (&c.CustomType).MarshalCanotoInto(w)
	}
	if !canoto.IsZero(c.CustomUint32) {
		canoto.Append(&w, canoto__Scalars__CustomUint32__tag)
		canoto.AppendFint32(&w, c.CustomUint32)
	}
	if len(c.CustomString) != 0 {
		canoto.Append(&w, canoto__Scalars__CustomString__tag)
		canoto.AppendBytes(&w, c.CustomString)
	}
	if len(c.CustomBytes) != 0 {
		canoto.Append(&w, canoto__Scalars__CustomBytes__tag)
		canoto.AppendBytes(&w, c.CustomBytes)
	}
	if !canoto.IsZero(c.CustomFixedBytes) {
		canoto.Append(&w, canoto__Scalars__CustomFixedBytes__tag)
		canoto.AppendBytes(&w, (&c.CustomFixedBytes)[:])
	}
	for _, v := range c.CustomRepeatedBytes {
		canoto.Append(&w, canoto__Scalars__CustomRepeatedBytes__tag)
		canoto.AppendBytes(&w, v)
	}
	{
		field := c.CustomRepeatedFixedBytes
		for i := range field {
			canoto.Append(&w, canoto__Scalars__CustomRepeatedFixedBytes__tag)
			canoto.AppendBytes(&w, (&field[i])[:])
		}
	}
	{
		isZero := true
		for _, v := range c.CustomFixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.CustomFixedRepeatedBytes {
				canoto.Append(&w, canoto__Scalars__CustomFixedRepeatedBytes__tag)
				canoto.AppendBytes(&w, v)
			}
		}
	}
	if !canoto.IsZero(c.CustomFixedRepeatedFixedBytes) {
		for i := range c.CustomFixedRepeatedFixedBytes {
			canoto.Append(&w, canoto__Scalars__CustomFixedRepeatedFixedBytes__tag)
			canoto.AppendBytes(&w, (&(&c.CustomFixedRepeatedFixedBytes)[i])[:])
		}
	}
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__OneOf__tag)
		canoto.AppendUint(&w, fieldSize)
		w = (&c.OneOf).MarshalCanotoInto(w)
	}
	if c.Pointer != nil {
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Scalars__Pointer__tag)
			canoto.AppendUint(&w, fieldSize)
			w = (c.Pointer).MarshalCanotoInto(w)
		}
	}
	{
		field := c.RepeatedPointer
		for i := range field {
			canoto.Append(&w, canoto__Scalars__RepeatedPointer__tag)
			var fieldSize uint64
			if field[i] != nil {
				fieldSize = (field[i]).CachedCanotoSize()
			}
			canoto.AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = (field[i]).MarshalCanotoInto(w)
			}
		}
	}
	{
		isZero := true
		field := c.FixedRepeatedPointer
		for i := range field {
			if field[i] != nil && (field[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedPointer__tag)
				var fieldSize uint64
				if field[i] != nil {
					fieldSize = (field[i]).CachedCanotoSize()
				}
				canoto.AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = (field[i]).MarshalCanotoInto(w)
				}
			}
		}
	}
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__Field__tag)
		canoto.AppendUint(&w, fieldSize)
		w = c.Field.MarshalCanotoInto(w)
	}
	{
		field := c.RepeatedField
		for i := range field {
			canoto.Append(&w, canoto__Scalars__RepeatedField__tag)
			fieldSize := field[i].CachedCanotoSize()
			canoto.AppendUint(&w, fieldSize)
			if fieldSize != 0 {
				w = field[i].MarshalCanotoInto(w)
			}
		}
	}
	{
		isZero := true
		field := c.FixedRepeatedField
		for i := range field {
			if field[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range field {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedField__tag)
				fieldSize := field[i].CachedCanotoSize()
				canoto.AppendUint(&w, fieldSize)
				if fieldSize != 0 {
					w = field[i].MarshalCanotoInto(w)
				}
			}
		}
	}
	return w
}

const (
	canoto__SpecUnusedZero__Bool__tag           = "\x08" // canoto.Tag(1, canoto.Varint)
	canoto__SpecUnusedZero__RepeatedBool__tag   = "\x12" // canoto.Tag(2, canoto.Len)
	canoto__SpecUnusedZero__String__tag         = "\x1a" // canoto.Tag(3, canoto.Len)
	canoto__SpecUnusedZero__RepeatedString__tag = "\x22" // canoto.Tag(4, canoto.Len)
	canoto__SpecUnusedZero__Bytes__tag          = "\x2a" // canoto.Tag(5, canoto.Len)
	canoto__SpecUnusedZero__RepeatedBytes__tag  = "\x32" // canoto.Tag(6, canoto.Len)
)

type canotoData_SpecUnusedZero struct {
	size atomic.Uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*SpecUnusedZero) CanotoSpec(...reflect.Type) *canoto.Spec {
	s := &canoto.Spec{
		Name: "SpecUnusedZero",
		Fields: []canoto.FieldType{
			{
				FieldNumber: 1,
				Name:        "Bool",
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: 2,
				Name:        "RepeatedBool",
				Repeated:    true,
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: 3,
				Name:        "String",
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: 4,
				Name:        "RepeatedString",
				Repeated:    true,
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: 5,
				Name:        "Bytes",
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber: 6,
				Name:        "RepeatedBytes",
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*SpecUnusedZero) MakeCanoto() *SpecUnusedZero {
	return new(SpecUnusedZero)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *SpecUnusedZero) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [canoto.Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *SpecUnusedZero) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = SpecUnusedZero{}
	c.canotoData.size.Store(uint64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBool(&r, &c.Bool); err != nil {
				return err
			}
			if canoto.IsZero(c.Bool) {
				return canoto.ErrZeroValue
			}
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeBool != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedBool = canoto.MakeSlice(c.RepeatedBool, numMsgBytes/canoto.SizeBool)
			field := c.RepeatedBool
			for i := range field {
				if err := canoto.ReadBool(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 3:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadString(&r, &c.String); err != nil {
				return err
			}
			if len(c.String) == 0 {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__SpecUnusedZero__RepeatedString__tag)
			if err != nil {
				return err
			}
			c.RepeatedString = canoto.MakeSlice(c.RepeatedString, countMinus1+1)
			field := c.RepeatedString

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadString(&r, &field[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__SpecUnusedZero__RepeatedString__tag):]
				if err := canoto.ReadString(&r, &field[i]); err != nil {
					return err
				}
			}
		case 5:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.Bytes); err != nil {
				return err
			}
			if len(c.Bytes) == 0 {
				return canoto.ErrZeroValue
			}
		case 6:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__SpecUnusedZero__RepeatedBytes__tag)
			if err != nil {
				return err
			}
			c.RepeatedBytes = canoto.MakeSlice(c.RepeatedBytes, countMinus1+1)
			field := c.RepeatedBytes

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadBytes(&r, &field[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__SpecUnusedZero__RepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &field[i]); err != nil {
					return err
				}
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *SpecUnusedZero) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !canoto.ValidString(c.String) {
		return false
	}
	for _, v := range c.RepeatedString {
		if !canoto.ValidString(v) {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *SpecUnusedZero) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if !canoto.IsZero(c.Bool) {
		size += uint64(len(canoto__SpecUnusedZero__Bool__tag)) + canoto.SizeBool
	}
	if num := uint64(len(c.RepeatedBool)); num != 0 {
		fieldSize := num * canoto.SizeBool
		size += uint64(len(canoto__SpecUnusedZero__RepeatedBool__tag)) + canoto.SizeUint(fieldSize) + fieldSize
	}
	if len(c.String) != 0 {
		size += uint64(len(canoto__SpecUnusedZero__String__tag)) + canoto.SizeBytes(c.String)
	}
	for _, v := range c.RepeatedString {
		size += uint64(len(canoto__SpecUnusedZero__RepeatedString__tag)) + canoto.SizeBytes(v)
	}
	if len(c.Bytes) != 0 {
		size += uint64(len(canoto__SpecUnusedZero__Bytes__tag)) + canoto.SizeBytes(c.Bytes)
	}
	for _, v := range c.RepeatedBytes {
		size += uint64(len(canoto__SpecUnusedZero__RepeatedBytes__tag)) + canoto.SizeBytes(v)
	}
	c.canotoData.size.Store(size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *SpecUnusedZero) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return c.canotoData.size.Load()
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *SpecUnusedZero) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [canoto.Writer] and returns the
// resulting [canoto.Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *SpecUnusedZero) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Bool) {
		canoto.Append(&w, canoto__SpecUnusedZero__Bool__tag)
		canoto.AppendBool(&w, true)
	}
	if num := uint64(len(c.RepeatedBool)); num != 0 {
		canoto.Append(&w, canoto__SpecUnusedZero__RepeatedBool__tag)
		canoto.AppendUint(&w, num*canoto.SizeBool)
		for _, v := range c.RepeatedBool {
			canoto.AppendBool(&w, v)
		}
	}
	if len(c.String) != 0 {
		canoto.Append(&w, canoto__SpecUnusedZero__String__tag)
		canoto.AppendBytes(&w, c.String)
	}
	for _, v := range c.RepeatedString {
		canoto.Append(&w, canoto__SpecUnusedZero__RepeatedString__tag)
		canoto.AppendBytes(&w, v)
	}
	if len(c.Bytes) != 0 {
		canoto.Append(&w, canoto__SpecUnusedZero__Bytes__tag)
		canoto.AppendBytes(&w, c.Bytes)
	}
	for _, v := range c.RepeatedBytes {
		canoto.Append(&w, canoto__SpecUnusedZero__RepeatedBytes__tag)
		canoto.AppendBytes(&w, v)
	}
	return w
}
