package examples

import (
	"unicode/utf8"

	"github.com/StephenButtolph/canoto"
)

// TODO: This file should be autogenerated
const (
	int32Tag    = "\x08" // canoto.Tag(1, canoto.Varint)
	int64Tag    = "\x10" // canoto.Tag(2, canoto.Varint)
	uint32Tag   = "\x18" // canoto.Tag(3, canoto.Varint)
	uint64Tag   = "\x20" // canoto.Tag(4, canoto.Varint)
	sint32Tag   = "\x28" // canoto.Tag(5, canoto.Varint)
	sint64Tag   = "\x30" // canoto.Tag(6, canoto.Varint)
	fixed32Tag  = "\x3d" // canoto.Tag(7, canoto.I32)
	fixed64Tag  = "\x41" // canoto.Tag(8, canoto.I64)
	sfixed32Tag = "\x4d" // canoto.Tag(9, canoto.I32)
	sfixed64Tag = "\x51" // canoto.Tag(10, canoto.I64)
	boolTag     = "\x58" // canoto.Tag(11, canoto.Varint)
	stringTag   = "\x62" // canoto.Tag(12, canoto.Len)
	bytesTag    = "\x6a" // canoto.Tag(13, canoto.Len)

	int32TagSize    = len(int32Tag)
	int64TagSize    = len(int64Tag)
	uint32TagSize   = len(uint32Tag)
	uint64TagSize   = len(uint64Tag)
	sint32TagSize   = len(sint32Tag)
	sint64TagSize   = len(sint64Tag)
	fixed32TagSize  = len(fixed32Tag)
	fixed64TagSize  = len(fixed64Tag)
	sfixed32TagSize = len(sfixed32Tag)
	sfixed64TagSize = len(sfixed64Tag)
	boolTagSize     = len(boolTag)
	stringTagSize   = len(stringTag)
	bytesTagSize    = len(bytesTag)
)

func (s *Scalars) UnmarshalCanoto(r *canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(r) {
		field, wireType, err := canoto.ReadTag(r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrInvalidWireType
			}
			s.Int32, err = canoto.ReadInt[int32](r)
		case 2:
			if wireType != canoto.Varint {
				return canoto.ErrInvalidWireType
			}
			s.Int64, err = canoto.ReadInt[int64](r)
		case 3:
			if wireType != canoto.Varint {
				return canoto.ErrInvalidWireType
			}
			s.Uint32, err = canoto.ReadInt[uint32](r)
		case 4:
			if wireType != canoto.Varint {
				return canoto.ErrInvalidWireType
			}
			s.Uint64, err = canoto.ReadInt[uint64](r)
		case 5:
			if wireType != canoto.Varint {
				return canoto.ErrInvalidWireType
			}
			s.Sint32, err = canoto.ReadSint[int32](r)
		case 6:
			if wireType != canoto.Varint {
				return canoto.ErrInvalidWireType
			}
			s.Sint64, err = canoto.ReadSint[int64](r)
		case 7:
			if wireType != canoto.I32 {
				return canoto.ErrInvalidWireType
			}
			s.Fixed32, err = canoto.ReadFint32[uint32](r)
		case 8:
			if wireType != canoto.I64 {
				return canoto.ErrInvalidWireType
			}
			s.Fixed64, err = canoto.ReadFint64[uint64](r)
		case 9:
			if wireType != canoto.I32 {
				return canoto.ErrInvalidWireType
			}
			s.Sfixed32, err = canoto.ReadFint32[int32](r)
		case 10:
			if wireType != canoto.I64 {
				return canoto.ErrInvalidWireType
			}
			s.Sfixed64, err = canoto.ReadFint64[int64](r)
		case 11:
			if wireType != canoto.Varint {
				return canoto.ErrInvalidWireType
			}
			s.Bool = true
			err = canoto.ReadTrue(r)
		case 12:
			if wireType != canoto.Len {
				return canoto.ErrInvalidWireType
			}
			s.String, err = canoto.ReadString(r)
		case 13:
			if wireType != canoto.Len {
				return canoto.ErrInvalidWireType
			}
			s.Bytes, err = canoto.ReadBytes(r)
		default:
			return canoto.ErrUnknownField
		}
		if err != nil {
			return err
		}

		minField = field + 1
	}
	return nil
}

func (s *Scalars) ValidCanoto() bool {
	return utf8.ValidString(s.String)
}

func (s *Scalars) SizeCanoto() int {
	var size int
	if s.Int32 != 0 {
		size += int32TagSize + canoto.SizeInt(s.Int32)
	}
	if s.Int64 != 0 {
		size += int64TagSize + canoto.SizeInt(s.Int64)
	}
	if s.Uint32 != 0 {
		size += uint32TagSize + canoto.SizeInt(s.Uint32)
	}
	if s.Uint64 != 0 {
		size += uint64TagSize + canoto.SizeInt(s.Uint64)
	}
	if s.Sint32 != 0 {
		size += sint32TagSize + canoto.SizeSint(s.Sint32)
	}
	if s.Sint64 != 0 {
		size += sint64TagSize + canoto.SizeSint(s.Sint64)
	}
	if s.Fixed32 != 0 {
		size += fixed32TagSize + canoto.SizeFint32
	}
	if s.Fixed64 != 0 {
		size += fixed64TagSize + canoto.SizeFint64
	}
	if s.Sfixed32 != 0 {
		size += sfixed32TagSize + canoto.SizeFint32
	}
	if s.Sfixed64 != 0 {
		size += sfixed64TagSize + canoto.SizeFint64
	}
	if s.Bool {
		size += boolTagSize + canoto.SizeBool
	}
	if len(s.String) != 0 {
		size += stringTagSize + canoto.SizeBytes(s.String)
	}
	if len(s.Bytes) != 0 {
		size += bytesTagSize + canoto.SizeBytes(s.Bytes)
	}
	return size
}

func (s *Scalars) MarshalCanoto(w *canoto.Writer) {
	if s.Int32 != 0 {
		canoto.Append(w, int32Tag)
		canoto.AppendInt(w, s.Int32)
	}
	if s.Int64 != 0 {
		canoto.Append(w, int64Tag)
		canoto.AppendInt(w, s.Int64)
	}
	if s.Uint32 != 0 {
		canoto.Append(w, uint32Tag)
		canoto.AppendInt(w, s.Uint32)
	}
	if s.Uint64 != 0 {
		canoto.Append(w, uint64Tag)
		canoto.AppendInt(w, s.Uint64)
	}
	if s.Sint32 != 0 {
		canoto.Append(w, sint32Tag)
		canoto.AppendSint(w, s.Sint32)
	}
	if s.Sint64 != 0 {
		canoto.Append(w, sint64Tag)
		canoto.AppendSint(w, s.Sint64)
	}
	if s.Fixed32 != 0 {
		canoto.Append(w, fixed32Tag)
		canoto.AppendFint32(w, s.Fixed32)
	}
	if s.Fixed64 != 0 {
		canoto.Append(w, fixed64Tag)
		canoto.AppendFint64(w, s.Fixed64)
	}
	if s.Sfixed32 != 0 {
		canoto.Append(w, sfixed32Tag)
		canoto.AppendFint32(w, s.Sfixed32)
	}
	if s.Sfixed64 != 0 {
		canoto.Append(w, sfixed64Tag)
		canoto.AppendFint64(w, s.Sfixed64)
	}
	if s.Bool {
		canoto.Append(w, boolTag)
		canoto.AppendTrue(w)
	}
	if len(s.String) != 0 {
		canoto.Append(w, stringTag)
		canoto.AppendBytes(w, s.String)
	}
	if len(s.Bytes) != 0 {
		canoto.Append(w, bytesTag)
		canoto.AppendBytes(w, s.Bytes)
	}
}
