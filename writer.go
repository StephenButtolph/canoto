package canoto

import (
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"strings"
)

const (
	fileTemplate = `// Code generated by Canoto. DO NOT EDIT.

package %s

import (
	"unicode/utf8"

	"github.com/StephenButtolph/canoto"
)

// Ensure that "unicode/utf8" is imported without error
var _ = utf8.ValidString
`

	structTemplate = `
const (
%s
%s)

type canotoData_%s struct {
%s}


func (c *%s) UnmarshalCanoto(r *canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(r) {
		field, wireType, err := canoto.ReadTag(r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
%s		default:
			return canoto.ErrUnknownField
		}
		if err != nil {
			return err
		}

		minField = field + 1
	}
	return nil
}

func (c *%s) ValidCanoto() bool {
	return %s
}

func (c *%s) SizeCanoto() int {
	var size int
%s	return size
}

func (c *%s) MarshalCanoto(w *canoto.Writer) {
%s}
`

	unmarshalCaseSimpleTemplate = `		case %d:
		if wireType != canoto.%s {
			return canoto.ErrInvalidWireType
		}
		c.%s, err = canoto.Read%s(r)
`

	unmarshalCaseBoolTemplate = `		case %d:
		if wireType != canoto.Varint {
			return canoto.ErrInvalidWireType
		}
		c.%s = true
		err = canoto.ReadTrue(r)
`

	unmarshalCaseCustomTemplate = `		case %d:
		if wireType != canoto.Len {
			return canoto.ErrInvalidWireType
		}

		originalUnsafe := r.Unsafe
		r.Unsafe = true
		var msgBytes []byte
		msgBytes, err = canoto.ReadBytes(r)
		r.Unsafe = originalUnsafe
		if err != nil {
			return err
		}

		remainingBytes := r.B
		r.B = msgBytes
		err = c.%s.UnmarshalCanoto(r)
		r.B = remainingBytes
`

	sizeIfIntTemplate = `	if c.%s != 0 {
		size += canoto__%s__%s__tag__size + canoto.SizeInt(c.%s)
	}
`

	sizeIfSintTemplate = `	if c.%s != 0 {
		size += canoto__%s__%s__tag__size + canoto.SizeSint(c.%s)
	}
`

	sizeIfFixedSizeTemplate = `	if c.%s != 0 {
		size += canoto__%s__%s__tag__size + canoto.Size%s
	}
`

	sizeIfBoolTemplate = `	if c.%s {
		size += canoto__%s__%s__tag__size + canoto.SizeBool
	}
`

	sizeIfBytesTemplate = `	if len(c.%s) != 0 {
		size += canoto__%s__%s__tag__size + canoto.SizeBytes(c.%s)
	}
`

	sizeIfCustomTemplate = `	c.canotoData.%sSize = c.%s.SizeCanoto()
	if c.canotoData.%sSize != 0 {
		size += canoto__%s__%s__tag__size + canoto.SizeInt(int64(c.canotoData.%sSize)) + c.canotoData.%sSize
	}
`

	marshalIfIntTemplate = `	if c.%s != 0 {
		canoto.Append(w, canoto__%s__%s__tag)
		canoto.AppendInt(w, c.%s)
	}
`

	marshalIfSintTemplate = `	if c.%s != 0 {
		canoto.Append(w, canoto__%s__%s__tag)
		canoto.AppendSint(w, c.%s)
	}
`

	marshalIfFint32Template = `	if c.%s != 0 {
		canoto.Append(w, canoto__%s__%s__tag)
		canoto.AppendFint32(w, c.%s)
	}
`

	marshalIfFint64Template = `	if c.%s != 0 {
		canoto.Append(w, canoto__%s__%s__tag)
		canoto.AppendFint64(w, c.%s)
	}
`

	marshalIfBoolTemplate = `	if c.%s {
		canoto.Append(w, canoto__%s__%s__tag)
		canoto.AppendTrue(w)
	}
`

	marshalIfBytesTemplate = `	if len(c.%s) != 0 {
		canoto.Append(w, canoto__%s__%s__tag)
		canoto.AppendBytes(w, c.%s)
	}
`

	marshalIfCustomTemplate = `	if c.canotoData.%sSize != 0 {
		canoto.Append(w, canoto__%s__%s__tag)
		canoto.AppendInt(w, int64(c.canotoData.%sSize))
		c.%s.MarshalCanoto(w)
	}
`
)

var errUnexpectedCanotoType = errors.New("unexpected canoto type")

func write(w io.Writer, packageName string, messages []message) error {
	_, err := fmt.Fprintf(
		w,
		fileTemplate,
		packageName,
	)
	if err != nil {
		return err
	}

	for _, m := range messages {
		if err := writeStruct(w, m); err != nil {
			return err
		}
	}
	return nil
}

func writeStruct(w io.Writer, m message) error {
	tagConstants, err := makeTagConstants(m)
	if err != nil {
		return err
	}
	unmarshalCases, err := makeUnmarshalCases(m)
	if err != nil {
		return err
	}
	sizeIfs, err := makeSizeIfs(m)
	if err != nil {
		return err
	}
	marshalIfs, err := makeMarshalIfs(m)
	if err != nil {
		return err
	}

	_, err = fmt.Fprintf(
		w,
		structTemplate,
		tagConstants, makeTagSizeConstants(m),
		m.name, makeSizeCache(m),
		m.name, unmarshalCases,
		m.name, makeValidConditions(m),
		m.name, sizeIfs,
		m.name, marshalIfs,
	)
	return err
}

func makeTagConstants(m message) (string, error) {
	var tagConstants strings.Builder
	canonicalizedMessageName := strings.ReplaceAll(m.name, "_", "_1")
	for _, f := range m.fields {
		canonicalizedFieldName := strings.ReplaceAll(f.name, "_", "_1")
		_, _ = fmt.Fprintf(
			&tagConstants,
			`	canoto__%s__%s__tag = "`,
			canonicalizedMessageName,
			canonicalizedFieldName,
		)

		var (
			wireType       WireType
			wireTypeString string
		)
		switch f.canotoType {
		case "int", "sint", "bool":
			wireType = Varint
			wireTypeString = "Varint"
		case "fint":
			switch f.goType {
			case "int32", "uint32":
				wireType = I32
				wireTypeString = "I32"
			case "int64", "uint64":
				wireType = I64
				wireTypeString = "I64"
			default:
				return "", fmt.Errorf("%w: %q with canotoType %q", errUnexpectedType, f.goType, f.canotoType)
			}
		case "bytes":
			wireType = Len
			wireTypeString = "Len"
		default:
			return "", fmt.Errorf("%w: %q", errUnexpectedCanotoType, f.canotoType)
		}

		tagBytes := Tag(f.fieldNumber, wireType)
		tagHex := hex.EncodeToString(tagBytes)
		for i := 0; i < len(tagHex); i += 2 {
			_, _ = fmt.Fprintf(&tagConstants, "\\x%s", tagHex[i:i+2])
		}
		_, _ = fmt.Fprintf(
			&tagConstants,
			"\" // canoto.Tag(%d, canoto.%s)\n",
			f.fieldNumber,
			wireTypeString,
		)
	}
	return tagConstants.String(), nil
}

func makeTagSizeConstants(m message) string {
	var (
		tagSizeConstants         strings.Builder
		canonicalizedMessageName = strings.ReplaceAll(m.name, "_", "_1")
	)
	for _, f := range m.fields {
		canonicalizedFieldName := strings.ReplaceAll(f.name, "_", "_1")
		_, _ = fmt.Fprintf(
			&tagSizeConstants,
			"\tcanoto__%s__%s__tag__size = len(canoto__%s__%s__tag)\n",
			canonicalizedMessageName,
			canonicalizedFieldName,
			canonicalizedMessageName,
			canonicalizedFieldName,
		)
	}
	return tagSizeConstants.String()
}

func makeSizeCache(m message) string {
	var sizeCache strings.Builder
	for _, f := range m.fields {
		switch f.goType {
		case "int32", "int64", "uint32", "uint64", "bool", "string", "[]byte":
			continue
		}

		_, _ = fmt.Fprintf(
			&sizeCache,
			"\t%sSize int\n",
			f.name,
		)
	}
	return sizeCache.String()
}

func makeUnmarshalCases(m message) (string, error) {
	var unmarshalCases strings.Builder
	for _, f := range m.fields {
		switch f.canotoType {
		case "int":
			_, _ = fmt.Fprintf(
				&unmarshalCases,
				unmarshalCaseSimpleTemplate,
				f.fieldNumber,
				"Varint",
				f.name,
				fmt.Sprintf("Int[%s]", f.goType),
			)
		case "sint":
			_, _ = fmt.Fprintf(
				&unmarshalCases,
				unmarshalCaseSimpleTemplate,
				f.fieldNumber,
				"Varint",
				f.name,
				fmt.Sprintf("Sint[%s]", f.goType),
			)
		case "fint":
			switch f.goType {
			case "int32", "uint32":
				_, _ = fmt.Fprintf(
					&unmarshalCases,
					unmarshalCaseSimpleTemplate,
					f.fieldNumber,
					"I32",
					f.name,
					fmt.Sprintf("Fint32[%s]", f.goType),
				)
			case "int64", "uint64":
				_, _ = fmt.Fprintf(
					&unmarshalCases,
					unmarshalCaseSimpleTemplate,
					f.fieldNumber,
					"I64",
					f.name,
					fmt.Sprintf("Fint64[%s]", f.goType),
				)
			default:
				return "", fmt.Errorf("%w: %q should have fixed size", errUnexpectedType, f.goType)
			}
		case "bool":
			_, _ = fmt.Fprintf(
				&unmarshalCases,
				unmarshalCaseBoolTemplate,
				f.fieldNumber,
				f.name,
			)
		case "bytes":
			switch f.goType {
			case "string":
				_, _ = fmt.Fprintf(
					&unmarshalCases,
					unmarshalCaseSimpleTemplate,
					f.fieldNumber,
					"Len",
					f.name,
					"String",
				)
			case "[]byte":
				_, _ = fmt.Fprintf(
					&unmarshalCases,
					unmarshalCaseSimpleTemplate,
					f.fieldNumber,
					"Len",
					f.name,
					"Bytes",
				)
			default:
				_, _ = fmt.Fprintf(
					&unmarshalCases,
					unmarshalCaseCustomTemplate,
					f.fieldNumber,
					f.name,
				)
			}
		default:
			return "", fmt.Errorf("%w: %q", errUnexpectedCanotoType, f.canotoType)
		}
	}
	return unmarshalCases.String(), nil
}

func makeValidConditions(m message) string {
	var validConditions strings.Builder
	for _, f := range m.fields {
		if f.canotoType != "bytes" || f.goType == "[]byte" {
			continue
		}

		if validConditions.Len() > 0 {
			_, _ = fmt.Fprint(&validConditions, " && ")
		}
		if f.goType == "string" {
			_, _ = fmt.Fprintf(
				&validConditions,
				"utf8.ValidString(c.%s)",
				f.name,
			)
		} else {
			_, _ = fmt.Fprintf(
				&validConditions,
				"c.%s.ValidCanoto()",
				f.name,
			)
		}
	}
	if validConditions.Len() == 0 {
		return "true"
	}
	return validConditions.String()
}

func makeSizeIfs(m message) (string, error) {
	var (
		sizeIfs                  strings.Builder
		canonicalizedMessageName = strings.ReplaceAll(m.name, "_", "_1")
	)
	for _, f := range m.fields {
		canonicalizedFieldName := strings.ReplaceAll(f.name, "_", "_1")
		switch f.canotoType {
		case "int":
			_, _ = fmt.Fprintf(
				&sizeIfs,
				sizeIfIntTemplate,
				f.name,
				canonicalizedMessageName,
				canonicalizedFieldName,
				f.name,
			)
		case "sint":
			_, _ = fmt.Fprintf(
				&sizeIfs,
				sizeIfSintTemplate,
				f.name,
				canonicalizedMessageName,
				canonicalizedFieldName,
				f.name,
			)
		case "fint":
			switch f.goType {
			case "int32", "uint32":
				_, _ = fmt.Fprintf(
					&sizeIfs,
					sizeIfFixedSizeTemplate,
					f.name,
					canonicalizedMessageName,
					canonicalizedFieldName,
					"Fint32",
				)
			case "int64", "uint64":
				_, _ = fmt.Fprintf(
					&sizeIfs,
					sizeIfFixedSizeTemplate,
					f.name,
					canonicalizedMessageName,
					canonicalizedFieldName,
					"Fint64",
				)
			default:
				return "", fmt.Errorf("%w: %q should have fixed size", errUnexpectedType, f.goType)
			}
		case "bool":
			_, _ = fmt.Fprintf(
				&sizeIfs,
				sizeIfBoolTemplate,
				f.name,
				canonicalizedMessageName,
				canonicalizedFieldName,
			)
		case "bytes":
			switch f.goType {
			case "string", "[]byte":
				_, _ = fmt.Fprintf(
					&sizeIfs,
					sizeIfBytesTemplate,
					f.name,
					canonicalizedMessageName,
					canonicalizedFieldName,
					f.name,
				)
			default:
				_, _ = fmt.Fprintf(
					&sizeIfs,
					sizeIfCustomTemplate,
					f.name,
					f.name,
					f.name,
					canonicalizedMessageName,
					canonicalizedFieldName,
					f.name,
					f.name,
				)
			}
		default:
			return "", fmt.Errorf("%w: %q", errUnexpectedCanotoType, f.canotoType)
		}
	}
	return sizeIfs.String(), nil
}

func makeMarshalIfs(m message) (string, error) {
	var (
		marshalIfs               strings.Builder
		canonicalizedMessageName = strings.ReplaceAll(m.name, "_", "_1")
	)
	for _, f := range m.fields {
		canonicalizedFieldName := strings.ReplaceAll(f.name, "_", "_1")
		switch f.canotoType {
		case "int":
			_, _ = fmt.Fprintf(
				&marshalIfs,
				marshalIfIntTemplate,
				f.name,
				canonicalizedMessageName,
				canonicalizedFieldName,
				f.name,
			)
		case "sint":
			_, _ = fmt.Fprintf(
				&marshalIfs,
				marshalIfSintTemplate,
				f.name,
				canonicalizedMessageName,
				canonicalizedFieldName,
				f.name,
			)
		case "fint":
			switch f.goType {
			case "int32", "uint32":
				_, _ = fmt.Fprintf(
					&marshalIfs,
					marshalIfFint32Template,
					f.name,
					canonicalizedMessageName,
					canonicalizedFieldName,
					f.name,
				)
			case "int64", "uint64":
				_, _ = fmt.Fprintf(
					&marshalIfs,
					marshalIfFint64Template,
					f.name,
					canonicalizedMessageName,
					canonicalizedFieldName,
					f.name,
				)
			default:
				return "", fmt.Errorf("%w: %q should have fixed size", errUnexpectedType, f.goType)
			}
		case "bool":
			_, _ = fmt.Fprintf(
				&marshalIfs,
				marshalIfBoolTemplate,
				f.name,
				canonicalizedMessageName,
				canonicalizedFieldName,
			)
		case "bytes":
			switch f.goType {
			case "string", "[]byte":
				_, _ = fmt.Fprintf(
					&marshalIfs,
					marshalIfBytesTemplate,
					f.name,
					canonicalizedMessageName,
					canonicalizedFieldName,
					f.name,
				)
			default:
				_, _ = fmt.Fprintf(
					&marshalIfs,
					marshalIfCustomTemplate,
					f.name,
					canonicalizedMessageName,
					canonicalizedFieldName,
					f.name,
					f.name,
				)
			}
		default:
			return "", fmt.Errorf("%w: %q", errUnexpectedCanotoType, f.canotoType)
		}
	}
	return marshalIfs.String(), nil
}
