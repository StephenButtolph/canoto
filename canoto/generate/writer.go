package generate

import (
	"encoding/hex"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/StephenButtolph/canoto"
)

const (
	fileTemplate = `// Code generated by Canoto. DO NOT EDIT.

package ${package}

import (
	"unicode/utf8"

	"github.com/StephenButtolph/canoto"
)

// Ensure that "unicode/utf8" is imported without error
var _ = utf8.ValidString
`

	structTemplate = `
const (
${tagConstants}
${tagSizeConstants})

type canotoData_${structName} struct {
${sizeCache}}

func (c *${structName}) UnmarshalCanoto(r *canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(r) {
		field, wireType, err := canoto.ReadTag(r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
${unmarshalCases}		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

func (c *${structName}) ValidCanoto() bool {
	return ${validityConditions}
}

func (c *${structName}) SizeCanoto() int {
	var size int
${sizeIfs}	return size
}

func (c *${structName}) MarshalCanoto(w *canoto.Writer) {
${marshalIfs}}
`

	unmarshalCaseSimpleTemplate = `		case ${fieldNumber}:
			if wireType != canoto.${wireType} {
				return canoto.ErrInvalidWireType
			}
			c.${fieldName}, err = canoto.Read${readFunction}(r)
			if err != nil {
				return err
			}
			if c.${fieldName} == 0 {
				return canoto.ErrZeroValue
			}
`

	unmarshalCaseBoolTemplate = `		case ${fieldNumber}:
			if wireType != canoto.Varint {
				return canoto.ErrInvalidWireType
			}
			c.${fieldName}, err = canoto.ReadBool(r)
			if err != nil {
				return err
			}
			if !c.${fieldName} {
				return canoto.ErrZeroValue
			}
`

	unmarshalCaseBytesTemplate = `		case ${fieldNumber}:
			if wireType != canoto.${wireType} {
				return canoto.ErrInvalidWireType
			}
			c.${fieldName}, err = canoto.Read${readFunction}(r)
			if err != nil {
				return err
			}
			if len(c.${fieldName}) == 0 {
				return canoto.ErrZeroValue
			}
`

	unmarshalCaseCustomTemplate = `		case ${fieldNumber}:
			if wireType != canoto.Len {
				return canoto.ErrInvalidWireType
			}

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			msgBytes, err = canoto.ReadBytes(r)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			err = c.${fieldName}.UnmarshalCanoto(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
`

	sizeIfIntTemplate = `	if c.${fieldName} != 0 {
		size += canoto__${escapedStructName}__${escapedFieldName}__tag__size + canoto.SizeInt(c.${fieldName})
	}
`

	sizeIfSintTemplate = `	if c.${fieldName} != 0 {
		size += canoto__${escapedStructName}__${escapedFieldName}__tag__size + canoto.SizeSint(c.${fieldName})
	}
`

	sizeIfFixedSizeTemplate = `	if c.${fieldName} != 0 {
		size += canoto__${escapedStructName}__${escapedFieldName}__tag__size + canoto.SizeFint${bitSize}
	}
`

	sizeIfBoolTemplate = `	if c.${fieldName} {
		size += canoto__${escapedStructName}__${escapedFieldName}__tag__size + canoto.SizeBool
	}
`

	sizeIfBytesTemplate = `	if len(c.${fieldName}) != 0 {
		size += canoto__${escapedStructName}__${escapedFieldName}__tag__size + canoto.SizeBytes(c.${fieldName})
	}
`

	sizeIfCustomTemplate = `	c.canotoData.${fieldName}Size = c.${fieldName}.SizeCanoto()
	if c.canotoData.${fieldName}Size != 0 {
		size += canoto__${escapedStructName}__${escapedFieldName}__tag__size + canoto.SizeInt(int64(c.canotoData.${fieldName}Size)) + c.canotoData.${fieldName}Size
	}
`

	marshalIfIntTemplate = `	if c.${fieldName} != 0 {
		canoto.Append(w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		canoto.AppendInt(w, c.${fieldName})
	}
`

	marshalIfSintTemplate = `	if c.${fieldName} != 0 {
		canoto.Append(w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		canoto.AppendSint(w, c.${fieldName})
	}
`

	marshalIfFintTemplate = `	if c.${fieldName} != 0 {
		canoto.Append(w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		canoto.AppendFint${bitSize}(w, c.${fieldName})
	}
`

	marshalIfBoolTemplate = `	if c.${fieldName} {
		canoto.Append(w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		canoto.AppendBool(w, true)
	}
`

	marshalIfBytesTemplate = `	if len(c.${fieldName}) != 0 {
		canoto.Append(w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		canoto.AppendBytes(w, c.${fieldName})
	}
`

	marshalIfCustomTemplate = `	if c.canotoData.${fieldName}Size != 0 {
		canoto.Append(w, canoto__${escapedStructName}__${escapedFieldName}__tag)
		canoto.AppendInt(w, int64(c.canotoData.${fieldName}Size))
		c.${fieldName}.MarshalCanoto(w)
	}
`
)

func write(w io.Writer, packageName string, messages []message) error {
	err := writeTemplate(w, fileTemplate, map[string]string{
		"package": packageName,
	})
	if err != nil {
		return err
	}

	for _, m := range messages {
		if err := writeStruct(w, m); err != nil {
			return err
		}
	}
	return nil
}

func writeStruct(w io.Writer, m message) error {
	tagConstants, err := makeTagConstants(m)
	if err != nil {
		return err
	}
	unmarshalCases, err := makeUnmarshalCases(m)
	if err != nil {
		return err
	}
	sizeIfs, err := makeSizeIfs(m)
	if err != nil {
		return err
	}
	marshalIfs, err := makeMarshalIfs(m)
	if err != nil {
		return err
	}

	return writeTemplate(w, structTemplate, map[string]string{
		"tagConstants":       tagConstants,
		"tagSizeConstants":   makeTagSizeConstants(m),
		"structName":         m.name,
		"sizeCache":          makeSizeCache(m),
		"unmarshalCases":     unmarshalCases,
		"validityConditions": makeValidConditions(m),
		"sizeIfs":            sizeIfs,
		"marshalIfs":         marshalIfs,
	})
}

func makeTagConstants(m message) (string, error) {
	var tagConstants strings.Builder
	for _, f := range m.fields {
		_, _ = fmt.Fprintf(
			&tagConstants,
			`	canoto__%s__%s__tag = "`,
			m.canonicalizedName,
			f.canonicalizedName,
		)

		wireType, err := f.WireType()
		if err != nil {
			return "", err
		}

		tagBytes := canoto.Tag(f.fieldNumber, wireType)
		tagHex := hex.EncodeToString(tagBytes)
		for i := 0; i < len(tagHex); i += 2 {
			_, _ = fmt.Fprintf(&tagConstants, "\\x%s", tagHex[i:i+2])
		}
		_, _ = fmt.Fprintf(
			&tagConstants,
			"\" // canoto.Tag(%d, canoto.%s)\n",
			f.fieldNumber,
			wireType,
		)
	}
	return tagConstants.String(), nil
}

func makeTagSizeConstants(m message) string {
	var tagSizeConstants strings.Builder
	for _, f := range m.fields {
		_, _ = fmt.Fprintf(
			&tagSizeConstants,
			"\tcanoto__%s__%s__tag__size = len(canoto__%s__%s__tag)\n",
			m.canonicalizedName,
			f.canonicalizedName,
			m.canonicalizedName,
			f.canonicalizedName,
		)
	}
	return tagSizeConstants.String()
}

func makeSizeCache(m message) string {
	var sizeCache strings.Builder
	for _, f := range m.fields {
		if f.goType.IsPrimitive() {
			continue
		}

		_, _ = fmt.Fprintf(
			&sizeCache,
			"\t%sSize int\n",
			f.name,
		)
	}
	return sizeCache.String()
}

func makeUnmarshalCases(m message) (string, error) {
	var unmarshalCases strings.Builder
	for _, f := range m.fields {
		var template string
		switch f.canotoType {
		case canotoInt, canotoSint, canotoFint:
			template = unmarshalCaseSimpleTemplate
		case canotoBool:
			template = unmarshalCaseBoolTemplate
		case canotoBytes:
			switch f.goType {
			case goString, goBytes:
				template = unmarshalCaseBytesTemplate
			default:
				template = unmarshalCaseCustomTemplate
			}
		default:
			return "", fmt.Errorf("%w: %q", errUnexpectedCanotoType, f.canotoType)
		}
		if err := writeTemplate(&unmarshalCases, template, f.templateArgs); err != nil {
			return "", err
		}
	}
	return unmarshalCases.String(), nil
}

func makeValidConditions(m message) string {
	var validConditions strings.Builder
	for _, f := range m.fields {
		if f.canotoType != canotoBytes || f.goType == goBytes {
			continue
		}

		// If there are multiple conditions, we need to merge them with an "&&"
		// separator
		if validConditions.Len() > 0 {
			_, _ = fmt.Fprint(&validConditions, " && ")
		}

		// goType is either string or a custom type
		if f.goType == goString {
			_, _ = fmt.Fprintf(
				&validConditions,
				"utf8.ValidString(c.%s)",
				f.name,
			)
		} else {
			_, _ = fmt.Fprintf(
				&validConditions,
				"c.%s.ValidCanoto()",
				f.name,
			)
		}
	}

	// If there are no conditions, we still need to implement the method, so we
	// just report that this message is valid.
	if validConditions.Len() == 0 {
		return "true"
	}
	return validConditions.String()
}

func makeSizeIfs(m message) (string, error) {
	var sizeIfs strings.Builder
	for _, f := range m.fields {
		var template string
		switch f.canotoType {
		case canotoInt:
			template = sizeIfIntTemplate
		case canotoSint:
			template = sizeIfSintTemplate
		case canotoFint:
			template = sizeIfFixedSizeTemplate
		case canotoBool:
			template = sizeIfBoolTemplate
		case canotoBytes:
			switch f.goType {
			case goString, goBytes:
				template = sizeIfBytesTemplate
			default:
				template = sizeIfCustomTemplate
			}
		default:
			return "", fmt.Errorf("%w: %q", errUnexpectedCanotoType, f.canotoType)
		}
		if err := writeTemplate(&sizeIfs, template, f.templateArgs); err != nil {
			return "", err
		}
	}
	return sizeIfs.String(), nil
}

func makeMarshalIfs(m message) (string, error) {
	var marshalIfs strings.Builder
	for _, f := range m.fields {
		var template string
		switch f.canotoType {
		case canotoInt:
			template = marshalIfIntTemplate
		case canotoSint:
			template = marshalIfSintTemplate
		case canotoFint:
			template = marshalIfFintTemplate
		case canotoBool:
			template = marshalIfBoolTemplate
		case canotoBytes:
			switch f.goType {
			case goString, goBytes:
				template = marshalIfBytesTemplate
			default:
				template = marshalIfCustomTemplate
			}
		default:
			return "", fmt.Errorf("%w: %q", errUnexpectedCanotoType, f.canotoType)
		}
		if err := writeTemplate(&marshalIfs, template, f.templateArgs); err != nil {
			return "", err
		}
	}
	return marshalIfs.String(), nil
}

func writeTemplate(w io.Writer, template string, args map[string]string) error {
	s := os.Expand(template, func(key string) string {
		return args[key]
	})
	_, err := w.Write([]byte(s))
	return err
}
