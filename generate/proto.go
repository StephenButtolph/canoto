package generate

import (
	"fmt"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/StephenButtolph/canoto"
)

const protoExtension = ".proto"

// Proto generates a corresponding proto file for the provided file.
func Proto(inputFilePath string) error {
	extension := filepath.Ext(inputFilePath)
	if extension != goExtension {
		return fmt.Errorf("%w not %q", errNonGoExtension, extension)
	}

	// Create a new parser
	fs := token.NewFileSet()
	f, err := parser.ParseFile(fs, inputFilePath, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	packageName, messages, err := parse(fs, f)
	if err != nil {
		return err
	}
	if len(messages) == 0 {
		return nil
	}

	outputFilePath := inputFilePath[:len(inputFilePath)-len(goExtension)] + protoExtension
	outputFile, err := os.Create(outputFilePath)
	if err != nil {
		return err
	}
	defer outputFile.Close()

	return writeProto(outputFile, inputFilePath, packageName, messages)
}

func writeProto(w io.Writer, source string, packageName string, messages []message) error {
	const fileTemplate = `// Code generated by canoto. DO NOT EDIT.
// versions:
// 	canoto ${version}
// source: ${source}

syntax = "proto3";

package ${package};
`
	err := writeTemplate(w, fileTemplate, map[string]string{
		"version": canoto.Version,
		"source":  source,
		"package": packageName,
	})
	if err != nil {
		return err
	}

	for _, m := range messages {
		if err := writeProtoMessage(w, m); err != nil {
			return err
		}
	}
	return nil
}

func writeProtoMessage(w io.Writer, m message) error {
	const structTemplate = `
message ${messageName} {
${fields}}
`

	return writeTemplate(w, structTemplate, map[string]string{
		"messageName": m.name,
		"fields":      makeFields(m),
	})
}

func makeFields(m message) string {
	const (
		template      = "  ${protoType} ${fieldName} = ${fieldNumber};\n"
		oneOfTemplate = "  " + template
	)
	var s strings.Builder
	for _, o := range m.OneOfs() {
		_, _ = s.WriteString(fmt.Sprintf("  oneof %s {\n", o))
		for _, f := range m.fields {
			if f.oneOfName != o {
				continue
			}

			_ = writeTemplate(&s, oneOfTemplate, f.templateArgs)
		}
		_, _ = s.WriteString("  }\n")
	}
	for _, f := range m.fields {
		if f.oneOfName != "" {
			continue
		}
		_ = writeTemplate(&s, template, f.templateArgs)
	}
	return s.String()
}
