package generate

import (
	"fmt"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/StephenButtolph/canoto"
)

const protoExtension = ".proto"

// Proto generates a corresponding proto file for the provided file.
func Proto(
	inputFilePath string,
	canotoImport string,
	internal bool,
) error {
	extension := filepath.Ext(inputFilePath)
	if extension != goExtension {
		return fmt.Errorf("%w not %q", errNonGoExtension, extension)
	}

	// Create a new parser
	fs := token.NewFileSet()
	f, err := parser.ParseFile(fs, inputFilePath, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	packageName, messages, err := parse(fs, f, canotoImport, internal)
	if err != nil {
		return err
	}
	if len(messages) == 0 {
		return nil
	}

	outputFilePath := inputFilePath[:len(inputFilePath)-len(goExtension)] + protoExtension
	outputFile, err := os.Create(outputFilePath)
	if err != nil {
		return err
	}
	defer outputFile.Close()

	return writeProto(outputFile, inputFilePath, packageName, messages)
}

func writeProto(w io.Writer, source string, packageName string, messages []message) error {
	const fileTemplate = `// Code generated by canoto. DO NOT EDIT.
// versions:
// 	canoto ${version}
// source: ${source}

syntax = "proto3";

package ${package};
`
	err := writeTemplate(w, fileTemplate, map[string]string{
		"version": canoto.Version,
		"source":  source,
		"package": packageName,
	})
	if err != nil {
		return err
	}

	customTypes := make(map[string]bool, len(messages))
	for _, m := range messages {
		customTypes[m.name] = true
	}
	for _, m := range messages {
		if err := writeProtoMessage(w, m, customTypes); err != nil {
			return err
		}
	}
	return nil
}

func writeProtoMessage(w io.Writer, m message, customTypes map[string]bool) error {
	const structTemplate = `
message ${messageName} {
${fields}}
`

	return writeTemplate(w, structTemplate, map[string]string{
		"messageName": m.name,
		"fields":      makeFields(m, customTypes),
	})
}

func makeFields(m message, customTypes map[string]bool) string {
	const (
		defaultTemplate      = "  ${protoTypePrefix}${protoTypeSuffix} ${fieldName} = ${fieldNumber};\n"
		oneOfDefaultTemplate = "  " + defaultTemplate

		specialTemplate      = "  ${protoTypePrefix}${protoType} ${fieldName} = ${fieldNumber};\n"
		oneOfSpecialTemplate = "  " + specialTemplate

		customTemplate      = "  ${protoTypePrefix}${goType} ${fieldName} = ${fieldNumber};\n"
		oneOfCustomTemplate = "  " + customTemplate
	)
	var s strings.Builder
	for _, o := range m.OneOfs() {
		_, _ = s.WriteString(fmt.Sprintf("  oneof %s {\n", o))
		for _, f := range m.fields {
			if f.oneOfName != o {
				continue
			}

			var template string
			switch {
			case f.protoType != "":
				template = oneOfSpecialTemplate
			case customTypes[f.goType]:
				template = oneOfCustomTemplate
			default:
				template = oneOfDefaultTemplate
			}
			_ = writeTemplate(&s, template, f.templateArgs)
		}
		_, _ = s.WriteString("  }\n")
	}
	for _, f := range m.fields {
		if f.oneOfName != "" {
			continue
		}

		var template string
		switch {
		case f.protoType != "":
			template = specialTemplate
		case customTypes[f.goType]:
			template = customTemplate
		default:
			template = defaultTemplate
		}
		_ = writeTemplate(&s, template, f.templateArgs)
	}
	return s.String()
}
